{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"mConfig Documentation \u00b6 mConfig is a modular Java library for unified, portable configuration management. It abstracts OS-specific locations (e.g., ~/.config/ , /etc/ , Windows Registry), multiple sources (files, env vars, JAR resources, ZooKeeper), and formats (JSON, YAML, TOML, Properties, etc.). The mConfig Tool is a powerful companion for exploring and managing these configurations from the command line. Core Principle : Layered resolution stack prioritizes scopes (highest first): ```mermaid graph LR POLICY[POLICY Enforced/GPO] --> RUNTIME[RUNTIME Volatile RAM] RUNTIME --> SESSION[SESSION Env/CLI] SESSION --> USER[USER ~/.config/] USER --> APPLICATION[APPLICATION Portable/Install] APPLICATION --> HOST[HOST /etc/, HKLM] HOST --> CLUSTER[CLUSTER ZK/Networks] CLUSTER --> CLOUD[CLOUD Providers] CLOUD --> ORGANIZATION[ORGANIZATION Licensee] ORGANIZATION --> PRODUCT[PRODUCT JAR Defaults] classDef high fill:#ff9999 class POLICY,RUNTIME high ``` Ties within scope: Later-added > earlier; storage prio: RAM > secrets > files > registry > JAR. Quick Start : What is mConfig? \u2192 Getting Started Architecture : Design Consolidated Part 1: Introduction & Basics \u00b6 1.1 What is mConfig? 1.2 Features and Use Cases 1.3 Getting Started 1.4 Regular Use 1.5 Test Mode Part 2: Core Concepts \u00b6 2.1 How it Works 2.2 Priorities and Hierarchies 2.3 Configuration Schemes 2.4 Comment Handling 2.5 Config Features Part 3: Advanced Topics \u00b6 3.1 Writing Configurations 3.2 Updates 3.3 Getting Information 3.4 Definitions and Valid Values 3.5 Handling Secrets 3.6 Windows Registry Access 3.7 Extensions and Advanced Use 3.8 Code Improvements and Best Practices Part 4: Reference & Project \u00b6 4.1 mConfig Tool 4.2 Logging 4.3 FAQ 4.4 Design Consolidated 4.5 AI Guidance (Notes for Code-Generating Tools) 4.6 Versions 4.7 Contributing 4.8 Legal Examples 4.9 Links and References","title":"Home"},{"location":"index.html#mconfig-documentation","text":"mConfig is a modular Java library for unified, portable configuration management. It abstracts OS-specific locations (e.g., ~/.config/ , /etc/ , Windows Registry), multiple sources (files, env vars, JAR resources, ZooKeeper), and formats (JSON, YAML, TOML, Properties, etc.). The mConfig Tool is a powerful companion for exploring and managing these configurations from the command line. Core Principle : Layered resolution stack prioritizes scopes (highest first): ```mermaid graph LR POLICY[POLICY Enforced/GPO] --> RUNTIME[RUNTIME Volatile RAM] RUNTIME --> SESSION[SESSION Env/CLI] SESSION --> USER[USER ~/.config/] USER --> APPLICATION[APPLICATION Portable/Install] APPLICATION --> HOST[HOST /etc/, HKLM] HOST --> CLUSTER[CLUSTER ZK/Networks] CLUSTER --> CLOUD[CLOUD Providers] CLOUD --> ORGANIZATION[ORGANIZATION Licensee] ORGANIZATION --> PRODUCT[PRODUCT JAR Defaults] classDef high fill:#ff9999 class POLICY,RUNTIME high ``` Ties within scope: Later-added > earlier; storage prio: RAM > secrets > files > registry > JAR. Quick Start : What is mConfig? \u2192 Getting Started Architecture : Design Consolidated","title":"mConfig Documentation"},{"location":"index.html#part-1-introduction-basics","text":"1.1 What is mConfig? 1.2 Features and Use Cases 1.3 Getting Started 1.4 Regular Use 1.5 Test Mode","title":"Part 1: Introduction &amp; Basics"},{"location":"index.html#part-2-core-concepts","text":"2.1 How it Works 2.2 Priorities and Hierarchies 2.3 Configuration Schemes 2.4 Comment Handling 2.5 Config Features","title":"Part 2: Core Concepts"},{"location":"index.html#part-3-advanced-topics","text":"3.1 Writing Configurations 3.2 Updates 3.3 Getting Information 3.4 Definitions and Valid Values 3.5 Handling Secrets 3.6 Windows Registry Access 3.7 Extensions and Advanced Use 3.8 Code Improvements and Best Practices","title":"Part 3: Advanced Topics"},{"location":"index.html#part-4-reference-project","text":"4.1 mConfig Tool 4.2 Logging 4.3 FAQ 4.4 Design Consolidated 4.5 AI Guidance (Notes for Code-Generating Tools) 4.6 Versions 4.7 Contributing 4.8 Legal Examples 4.9 Links and References","title":"Part 4: Reference &amp; Project"},{"location":"11_what_is_mconfig.html","text":"1.1 What is mConfig? \u00b6 mConfig: unified, portable configuration access What is it? \u00b6 mConfig is a (Java) library for configuration access. It allows to access configuration data without prior knowledge. compliant with OS/platform rules from many sources (files, network, hardware, registries, environment, \u2026) in many formats (.properties, JSON, YAML, \u2026) It consists of several modules, so it can be kept small and adapted to the specific use case. minimal example \u00b6 Configuration cfg = ConfigUtil . quickConfig ( \"ACME\" , \"ourApp\" , \"itsConfig\" ); String message = cfg . getString ( \"hello\" ); System . out . println ( message ); See examples for the recommended way to do this, and sample code for some use cases. getting started \u00b6 Proceed to the Getting Started section for step-by-step instructions on integrating mConfig into your project, including dependencies, first code examples, and resource placement. Features \u00b6 unifying access, abstracting OS specifics cross-platform development support for CI/CD and automated testing not a framework, but a modular library File formats supported: JSON, JSON5, YAML, TOML, INI, Java Properties, raw binary and raw text files File formats planned: ASN.1 and PEM, DHALL, HOCON. Open Source \u00b6 mConfig is an open source project distributed under the CC-BY-ND 4.0 license. Commercial use is free of charge. The source code is available on github. Status \u00b6 mConfig as of 0.7 is in pre-release; usable, but work in progress Citing mConfig \u00b6 If you use mConfig in research or technical documentation, you can cite it as: metabit JWilkes. mConfig: Unified Configuration Access (2002-present). Available at: https://metabit.org @misc { mConfig , author = { J.Wilkes, metabit } , title = {mConfig: Unified Configuration Access} , year = {2026} , url = {https://metabit.org/} }","title":"1.1 What is mConfig?"},{"location":"11_what_is_mconfig.html#11-what-is-mconfig","text":"mConfig: unified, portable configuration access","title":"1.1 What is mConfig?"},{"location":"11_what_is_mconfig.html#what-is-it","text":"mConfig is a (Java) library for configuration access. It allows to access configuration data without prior knowledge. compliant with OS/platform rules from many sources (files, network, hardware, registries, environment, \u2026) in many formats (.properties, JSON, YAML, \u2026) It consists of several modules, so it can be kept small and adapted to the specific use case.","title":"What is it?"},{"location":"11_what_is_mconfig.html#minimal-example","text":"Configuration cfg = ConfigUtil . quickConfig ( \"ACME\" , \"ourApp\" , \"itsConfig\" ); String message = cfg . getString ( \"hello\" ); System . out . println ( message ); See examples for the recommended way to do this, and sample code for some use cases.","title":"minimal example"},{"location":"11_what_is_mconfig.html#getting-started","text":"Proceed to the Getting Started section for step-by-step instructions on integrating mConfig into your project, including dependencies, first code examples, and resource placement.","title":"getting started"},{"location":"11_what_is_mconfig.html#features","text":"unifying access, abstracting OS specifics cross-platform development support for CI/CD and automated testing not a framework, but a modular library File formats supported: JSON, JSON5, YAML, TOML, INI, Java Properties, raw binary and raw text files File formats planned: ASN.1 and PEM, DHALL, HOCON.","title":"Features"},{"location":"11_what_is_mconfig.html#open-source","text":"mConfig is an open source project distributed under the CC-BY-ND 4.0 license. Commercial use is free of charge. The source code is available on github.","title":"Open Source"},{"location":"11_what_is_mconfig.html#status","text":"mConfig as of 0.7 is in pre-release; usable, but work in progress","title":"Status"},{"location":"11_what_is_mconfig.html#citing-mconfig","text":"If you use mConfig in research or technical documentation, you can cite it as: metabit JWilkes. mConfig: Unified Configuration Access (2002-present). Available at: https://metabit.org @misc { mConfig , author = { J.Wilkes, metabit } , title = {mConfig: Unified Configuration Access} , year = {2026} , url = {https://metabit.org/} }","title":"Citing mConfig"},{"location":"12_features_and_use_cases.html","text":"1.2 Features and Use Cases \u00b6 mConfig abstracts configuration access. mConfig: abstracts OS platform differences in configuration locations makes cross-platform configuration access easier abstracts config file formats automatically detects changes to configuration sources provides a fallback hierarchy for defaults supports hierarchical scopes, e.g. user settings override local installation settings provides a TEST mode for automated tests supports development vs. production separation supports optional parameter type checking and parsing supports runtime documentation supports build-time documentation generation You set things up, then your code can just getInteger(), getString(), getBoolean(), getBigDecimal() and so on from the Configuration object, whenever it needs a config value. handles XDG Desktop standards overrides supports late-bound configurations (useful e.g. in cloud-native environments) supports multiple configuration sources","title":"1.2 Features and Use Cases"},{"location":"12_features_and_use_cases.html#12-features-and-use-cases","text":"mConfig abstracts configuration access. mConfig: abstracts OS platform differences in configuration locations makes cross-platform configuration access easier abstracts config file formats automatically detects changes to configuration sources provides a fallback hierarchy for defaults supports hierarchical scopes, e.g. user settings override local installation settings provides a TEST mode for automated tests supports development vs. production separation supports optional parameter type checking and parsing supports runtime documentation supports build-time documentation generation You set things up, then your code can just getInteger(), getString(), getBoolean(), getBigDecimal() and so on from the Configuration object, whenever it needs a config value. handles XDG Desktop standards overrides supports late-bound configurations (useful e.g. in cloud-native environments) supports multiple configuration sources","title":"1.2 Features and Use Cases"},{"location":"13_getting_started.html","text":"1.3 Getting Started \u00b6 1.3.1 Include the library in your project build \u00b6 For Java, start with adding the dependency to your project build: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}' (update version as needed) In case you are defining an module-info.java in your project, add this to the requires section: requires metabit . mconfig . core ; requires metabit . mconfig . util ; Starters (Recommended) \u00b6 For instant frustration-free setup, copy from examples/starters : mvn compile exec:java ./gradlew run mvn compile exec:java (module-info included!) See each README for details. Snippets (Quick Wins \ud83d\ude80) \u00b6 Copy-paste solutions for common config pains: hardcodes \u2192 env vars \u2192 secrets \u2192 tests. 1.3.2 Start with a simple use case \u00b6 Config cfg = ConfigUtil . quickConfig ( \"myCompany\" , \"myApplication\" , \"network\" ); String peerName = cfg . getString ( \"peer\" ); int portNumber = cfg . getInteger ( \"port\" ); double probability = cfg . getDouble ( \"probability\" ); //... This will get you the requested values from the \"network\" configuration, wherever in the standard directories or other places they are kept. If it's not working as expected, consult the Quick Verification Checklist in the FAQ. For more information on how to define the contract for your configurations (keys, types, defaults, and validation), see Configuration Schemes . 1.3.3 Common Pitfalls \u00b6 For advice on avoiding typical mistakes and leveraging feature flags effectively, see Code Improvements and Best Practices . 1.3.4 Resource Placement (the .config/ folder) \u00b6 To bundle configurations, schemes, or library settings with your application, use the .config/ resource folder in your classpath (e.g., src/main/resources/.config/ ). Configurations : .config/<company>/<application>/<configName>.<ext> Schemes : .config/<company>/<application>/<configName>.scheme.json Library Self-Configuration : .config/metabit/mConfig/mconfig.properties For testing, as a starting point, you can create a .config/myCompany/myApplication/network.properties in subdirectories of your home directory, and see its contents turn up in your code. Regular paths would be in /etc/myCompany/myApplication/network.properties for Linux, %AppData%\\myCompany\\myApplication\\network.properties for Windows, and so on - and taking care of all these different locations is part of the library. Also, parsing different formats like JSON, YAML, and so on. And much more. The cleaner way, without shortcuts, goes like this: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { Config cfg = factory . getConfiguration ( \"network\" ); String peerName = cfg . getString ( \"peer\" ); int portNumber = cfg . getInteger ( \"port\" ); double probability = cfg . getDouble ( \"probability\" ); //... } The try-with-resources in the top line instantiates the library with all defaults; the getConfiguration() line asks for a specific configuration, and then you can get config entries, typesafe. You can also list all available configuration names: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { Set < ConfigDiscoveryInfo > info = factory . listAvailableConfigurations (); for ( ConfigDiscoveryInfo c : info ) { System . out . println ( \"Found: \" + c . getConfigName () + \" in scope \" + c . getScope () + \" URL: \" + c . getUri ()); } } Caveat : When you use the values stored in your local variables, you miss out on receiving changes. It is preferable to use the mConfig objects directly; they'll have the latest values. 1.3.5 Search List and Priority \u00b6 Everything should just work, by default. But in some environments, you may want to customize the search list, or the storage types priority, or the file format priority... You can add extra directories to the search list, or change the priority of the storage types. see 2.2 Priorities and Hierarchies for details. 1.3.6 Navigating Lists with ConfigCursor \u00b6 Configuration formats that support arrays (like YAML, JSON, or TOML) may have lists/sets where the entries are not named, have no key. So you can't access them by name. You can use the ConfigCursor to navigate through list items as individual nodes. (Actually, you can use the ConfigCursor for all the configuration; it is just especially useful for navigating lists.) try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApp\" ). build ()) { Config cfg = factory . getConfig ( \"myConfig\" ); ConfigCursor cursor = cfg . getConfigCursor (); if ( cursor . moveTo ( \"servers\" ) && cursor . isOnList ()) { cursor . enter (); // Move into the array while ( cursor . moveNext ()) { // Now positioned on a list item. // Items can be accessed as unnamed entries via virtual keys (indices). ConfigEntry item = cursor . getCurrentElement (); System . out . println ( \"Server: \" + item . getValueAsString ()); } cursor . leave (); // Move back up to the \"servers\" node } } 1.3.7 Module System Considerations \u00b6 mConfig uses the Java Module System. The architecture is: mConfigBase : Aggregator module that bundles some standard dependencies metabit.mconfig.core : Core functionality metabit.mconfig.util : Utility functions Additional modules (e.g. Formats and configuration sources) When using Java modules, you must: 1. Include mConfigBase as a Maven/Gradle dependency 2. Explicitly require the core modules in your module-info.java 3. Require any additional modules you may need The internal modules are provided via services and do not have an API for your use, so you don't need to \"require\" them in your module-info.java .","title":"1.3 Getting Started"},{"location":"13_getting_started.html#13-getting-started","text":"","title":"1.3 Getting Started"},{"location":"13_getting_started.html#131-include-the-library-in-your-project-build","text":"For Java, start with adding the dependency to your project build: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}' (update version as needed) In case you are defining an module-info.java in your project, add this to the requires section: requires metabit . mconfig . core ; requires metabit . mconfig . util ;","title":"1.3.1 Include the library in your project build"},{"location":"13_getting_started.html#starters-recommended","text":"For instant frustration-free setup, copy from examples/starters : mvn compile exec:java ./gradlew run mvn compile exec:java (module-info included!) See each README for details.","title":"Starters (Recommended)"},{"location":"13_getting_started.html#snippets-quick-wins","text":"Copy-paste solutions for common config pains: hardcodes \u2192 env vars \u2192 secrets \u2192 tests.","title":"Snippets (Quick Wins \ud83d\ude80)"},{"location":"13_getting_started.html#132-start-with-a-simple-use-case","text":"Config cfg = ConfigUtil . quickConfig ( \"myCompany\" , \"myApplication\" , \"network\" ); String peerName = cfg . getString ( \"peer\" ); int portNumber = cfg . getInteger ( \"port\" ); double probability = cfg . getDouble ( \"probability\" ); //... This will get you the requested values from the \"network\" configuration, wherever in the standard directories or other places they are kept. If it's not working as expected, consult the Quick Verification Checklist in the FAQ. For more information on how to define the contract for your configurations (keys, types, defaults, and validation), see Configuration Schemes .","title":"1.3.2 Start with a simple use case"},{"location":"13_getting_started.html#133-common-pitfalls","text":"For advice on avoiding typical mistakes and leveraging feature flags effectively, see Code Improvements and Best Practices .","title":"1.3.3 Common Pitfalls"},{"location":"13_getting_started.html#134-resource-placement-the-config-folder","text":"To bundle configurations, schemes, or library settings with your application, use the .config/ resource folder in your classpath (e.g., src/main/resources/.config/ ). Configurations : .config/<company>/<application>/<configName>.<ext> Schemes : .config/<company>/<application>/<configName>.scheme.json Library Self-Configuration : .config/metabit/mConfig/mconfig.properties For testing, as a starting point, you can create a .config/myCompany/myApplication/network.properties in subdirectories of your home directory, and see its contents turn up in your code. Regular paths would be in /etc/myCompany/myApplication/network.properties for Linux, %AppData%\\myCompany\\myApplication\\network.properties for Windows, and so on - and taking care of all these different locations is part of the library. Also, parsing different formats like JSON, YAML, and so on. And much more. The cleaner way, without shortcuts, goes like this: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { Config cfg = factory . getConfiguration ( \"network\" ); String peerName = cfg . getString ( \"peer\" ); int portNumber = cfg . getInteger ( \"port\" ); double probability = cfg . getDouble ( \"probability\" ); //... } The try-with-resources in the top line instantiates the library with all defaults; the getConfiguration() line asks for a specific configuration, and then you can get config entries, typesafe. You can also list all available configuration names: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { Set < ConfigDiscoveryInfo > info = factory . listAvailableConfigurations (); for ( ConfigDiscoveryInfo c : info ) { System . out . println ( \"Found: \" + c . getConfigName () + \" in scope \" + c . getScope () + \" URL: \" + c . getUri ()); } } Caveat : When you use the values stored in your local variables, you miss out on receiving changes. It is preferable to use the mConfig objects directly; they'll have the latest values.","title":"1.3.4 Resource Placement (the .config/ folder)"},{"location":"13_getting_started.html#135-search-list-and-priority","text":"Everything should just work, by default. But in some environments, you may want to customize the search list, or the storage types priority, or the file format priority... You can add extra directories to the search list, or change the priority of the storage types. see 2.2 Priorities and Hierarchies for details.","title":"1.3.5 Search List and Priority"},{"location":"13_getting_started.html#136-navigating-lists-with-configcursor","text":"Configuration formats that support arrays (like YAML, JSON, or TOML) may have lists/sets where the entries are not named, have no key. So you can't access them by name. You can use the ConfigCursor to navigate through list items as individual nodes. (Actually, you can use the ConfigCursor for all the configuration; it is just especially useful for navigating lists.) try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApp\" ). build ()) { Config cfg = factory . getConfig ( \"myConfig\" ); ConfigCursor cursor = cfg . getConfigCursor (); if ( cursor . moveTo ( \"servers\" ) && cursor . isOnList ()) { cursor . enter (); // Move into the array while ( cursor . moveNext ()) { // Now positioned on a list item. // Items can be accessed as unnamed entries via virtual keys (indices). ConfigEntry item = cursor . getCurrentElement (); System . out . println ( \"Server: \" + item . getValueAsString ()); } cursor . leave (); // Move back up to the \"servers\" node } }","title":"1.3.6 Navigating Lists with ConfigCursor"},{"location":"13_getting_started.html#137-module-system-considerations","text":"mConfig uses the Java Module System. The architecture is: mConfigBase : Aggregator module that bundles some standard dependencies metabit.mconfig.core : Core functionality metabit.mconfig.util : Utility functions Additional modules (e.g. Formats and configuration sources) When using Java modules, you must: 1. Include mConfigBase as a Maven/Gradle dependency 2. Explicitly require the core modules in your module-info.java 3. Require any additional modules you may need The internal modules are provided via services and do not have an API for your use, so you don't need to \"require\" them in your module-info.java .","title":"1.3.7 Module System Considerations"},{"location":"14_regular_use.html","text":"1.4 Regular Use \u00b6 1.4.1 Providing a default configuration (PRODUCT scope) \u00b6 The lowest-priority layer is PRODUCT scope. Defaults come from two places: - ConfigScheme defaults (recommended for typed, documented defaults) - JAR resources (optional: ship default config files inside the JAR) For JAR resources, mConfig searches these paths (in order): - .config/[<company>/]<application>/<configName>.<ext> - .config/<application>/<configName>.<ext> - .config/<configName>.<ext> In a Maven/Gradle project, place them here: - src/main/resources/.config/[<company>/]<application>/<configName>.<ext> (production) - src/test/resources/.config/[<company>/]<application>/<configName>.<ext> (tests) Note : <company> optional; omitted if blank/null/whitespace. Normally, one should supply both company and application names. (company, organization, vendor, etc - we use \"company\" here for brevity.) While it is possible to omit the company name, it is not recommended. Some environments may use no company name by convention, but developing multi-platform, ConfigScheme defaults are always part of the PRODUCT scope default layer. If you want schemes to replace existing defaults rather than merge them, use SCHEME_RESETS_DEFAULTS . Note: JAR defaults are active when running from a JAR, but during development the JAR source still reads resources from the classpath, so the same paths work in IDE runs. 1.4.2 Configuration Schemes Discovery \u00b6 Config Schemes ( *.scheme.json ) are automatically discovered from the .config/ directory on the classpath. Development Time: Both src/main/resources/.config/ and src/test/resources/.config/ are searched. Precedence: If a scheme for the same configuration name exists in both locations, the one found last by the ClassLoader takes precedence. Production vs Test: Unlike configuration data, schemes are not bypassed in TEST_MODE . Production schemes are always loaded from the classpath to ensure the configuration contract is maintained. Recommended: Place in the main resources only. Schemes are a \"contract\" for the configurations, so they should be valid both for testing and production. Most IDE don't do the testing with JAR files, they run class files from the directories instead. The JAR config source won't just take any relative path for its default values; either the files are within the JAR, or it refuses to use them. That is intentional behaviour for security and safety purposes. You can activate Test Mode , however: In Test Mode, the relative paths are accepted (along with all the other directories test mode uses). 1.4.3 Use a config scheme \u00b6 1.4.3.1 Reasons \u00b6 There are some benefits to declaring the contents of your configurations separately from the code. - better maintenance (all in one place, instead of scattered) - enables automated documentation (both runtime and compile-time), which is always up-to-date with the code, without extra work. - type safety for your configuration parameters - automatic parameter validation before your code gets the values. Ideally, for a configuration there is just theme ConfigScheme you declared, and the key names your code uses. Once the mConfig Configuration is instantiated, the sole connection between the code and the values should be the keys it asks for. (In the API, we stick with String keys for ease of use. If you want to be strict in your development, you can declare an enum and use its names as keys.) 1.4.3.2 Normal use \u00b6 Normally, you'll place a JSON file in a subfolder of your resource directory, and that's it. The file name is the name of the Configuration you want to use, plus the suffix \".scheme.json\". It is a JSON(-style) file, following a specific format (see Configuration Schemes ) You declare all the configuration parameters your code can or will use. mConfig will automatically detect and use these files. Example: If your code uses a Configuration named \"MyConfig\" for Company \"MyCompany\" and Application \"MyApplication\", you would place the corresponding scheme file in src/main/resources/.config/MyCompany/MyApplication/MyConfig.scheme.json 1.4.3.3 Explicit setting \u00b6 If, for reasons whatsoever, you want to provide the configuration scheme yourself, prepare the JSON string according to the format. Convert it to a ConfigScheme ConfigScheme testScheme = ConfigScheme.statics.fromJSON(yourConfigSchemeString); and apply it to the respective Configuration cfg.setConfigScheme(testScheme); . Note: default values in your scheme will replace potentially existing defaults. 1.4.4 Runtime Dynamic Configurations \u00b6 Mutable Puts: you can change the values of existing entries at runtime. Example: configFactory . put ( \"voting.database.name\" , \"dynamicDB\" , ConfigScope . RUNTIME ); The RUNTIME scope is at the highest priority \u00b9, so it overrides all others. So dynamically changing the configuration at runtime is quite possible. \u00b9: the highest priority of all regular scopes, that is. the POLICY scope can enforce its settings over everything else; that's for security reasons. 1.4.5 Put and write \u00b6 Configurations can be written to; the put operation is the same for all scopes. The puts are typed. You can pick either a single scope, or an enum set of scopes. When writing, mConfig follows the \"principle of least surprise\" when writing to a scope: - If an entry for the key already exists in a writeable layer within the scope, its contents are changed, and written. - If no entry for the key exists in the scope yet, it is created and written, if there is a writeable layer available within the scope or scopes specified. - If no writeable layer is available in the scope, the put fails with an exception. No silent data loss.","title":"1.4 Regular Use"},{"location":"14_regular_use.html#14-regular-use","text":"","title":"1.4 Regular Use"},{"location":"14_regular_use.html#141-providing-a-default-configuration-product-scope","text":"The lowest-priority layer is PRODUCT scope. Defaults come from two places: - ConfigScheme defaults (recommended for typed, documented defaults) - JAR resources (optional: ship default config files inside the JAR) For JAR resources, mConfig searches these paths (in order): - .config/[<company>/]<application>/<configName>.<ext> - .config/<application>/<configName>.<ext> - .config/<configName>.<ext> In a Maven/Gradle project, place them here: - src/main/resources/.config/[<company>/]<application>/<configName>.<ext> (production) - src/test/resources/.config/[<company>/]<application>/<configName>.<ext> (tests) Note : <company> optional; omitted if blank/null/whitespace. Normally, one should supply both company and application names. (company, organization, vendor, etc - we use \"company\" here for brevity.) While it is possible to omit the company name, it is not recommended. Some environments may use no company name by convention, but developing multi-platform, ConfigScheme defaults are always part of the PRODUCT scope default layer. If you want schemes to replace existing defaults rather than merge them, use SCHEME_RESETS_DEFAULTS . Note: JAR defaults are active when running from a JAR, but during development the JAR source still reads resources from the classpath, so the same paths work in IDE runs.","title":"1.4.1 Providing a default configuration (PRODUCT scope)"},{"location":"14_regular_use.html#142-configuration-schemes-discovery","text":"Config Schemes ( *.scheme.json ) are automatically discovered from the .config/ directory on the classpath. Development Time: Both src/main/resources/.config/ and src/test/resources/.config/ are searched. Precedence: If a scheme for the same configuration name exists in both locations, the one found last by the ClassLoader takes precedence. Production vs Test: Unlike configuration data, schemes are not bypassed in TEST_MODE . Production schemes are always loaded from the classpath to ensure the configuration contract is maintained. Recommended: Place in the main resources only. Schemes are a \"contract\" for the configurations, so they should be valid both for testing and production. Most IDE don't do the testing with JAR files, they run class files from the directories instead. The JAR config source won't just take any relative path for its default values; either the files are within the JAR, or it refuses to use them. That is intentional behaviour for security and safety purposes. You can activate Test Mode , however: In Test Mode, the relative paths are accepted (along with all the other directories test mode uses).","title":"1.4.2 Configuration Schemes Discovery"},{"location":"14_regular_use.html#143-use-a-config-scheme","text":"","title":"1.4.3 Use a config scheme"},{"location":"14_regular_use.html#1431-reasons","text":"There are some benefits to declaring the contents of your configurations separately from the code. - better maintenance (all in one place, instead of scattered) - enables automated documentation (both runtime and compile-time), which is always up-to-date with the code, without extra work. - type safety for your configuration parameters - automatic parameter validation before your code gets the values. Ideally, for a configuration there is just theme ConfigScheme you declared, and the key names your code uses. Once the mConfig Configuration is instantiated, the sole connection between the code and the values should be the keys it asks for. (In the API, we stick with String keys for ease of use. If you want to be strict in your development, you can declare an enum and use its names as keys.)","title":"1.4.3.1 Reasons"},{"location":"14_regular_use.html#1432-normal-use","text":"Normally, you'll place a JSON file in a subfolder of your resource directory, and that's it. The file name is the name of the Configuration you want to use, plus the suffix \".scheme.json\". It is a JSON(-style) file, following a specific format (see Configuration Schemes ) You declare all the configuration parameters your code can or will use. mConfig will automatically detect and use these files. Example: If your code uses a Configuration named \"MyConfig\" for Company \"MyCompany\" and Application \"MyApplication\", you would place the corresponding scheme file in src/main/resources/.config/MyCompany/MyApplication/MyConfig.scheme.json","title":"1.4.3.2 Normal use"},{"location":"14_regular_use.html#1433-explicit-setting","text":"If, for reasons whatsoever, you want to provide the configuration scheme yourself, prepare the JSON string according to the format. Convert it to a ConfigScheme ConfigScheme testScheme = ConfigScheme.statics.fromJSON(yourConfigSchemeString); and apply it to the respective Configuration cfg.setConfigScheme(testScheme); . Note: default values in your scheme will replace potentially existing defaults.","title":"1.4.3.3 Explicit setting"},{"location":"14_regular_use.html#144-runtime-dynamic-configurations","text":"Mutable Puts: you can change the values of existing entries at runtime. Example: configFactory . put ( \"voting.database.name\" , \"dynamicDB\" , ConfigScope . RUNTIME ); The RUNTIME scope is at the highest priority \u00b9, so it overrides all others. So dynamically changing the configuration at runtime is quite possible. \u00b9: the highest priority of all regular scopes, that is. the POLICY scope can enforce its settings over everything else; that's for security reasons.","title":"1.4.4 Runtime Dynamic Configurations"},{"location":"14_regular_use.html#145-put-and-write","text":"Configurations can be written to; the put operation is the same for all scopes. The puts are typed. You can pick either a single scope, or an enum set of scopes. When writing, mConfig follows the \"principle of least surprise\" when writing to a scope: - If an entry for the key already exists in a writeable layer within the scope, its contents are changed, and written. - If no entry for the key exists in the scope yet, it is created and written, if there is a writeable layer available within the scope or scopes specified. - If no writeable layer is available in the scope, the put fails with an exception. No silent data loss.","title":"1.4.5 Put and write"},{"location":"15_test_mode.html","text":"1.5 Test Mode \u00b6 mConfig has a test mode. This is to support software using mConfig in performing automated tests. Test mode supports: - manual tests by individual developers, - unit and integration testing, - the CI/CD pipeline test environment. One of the problems with tests is to replace the real, runtime environment with the test environment \u2013 preferably with as little residue in the actual code as possible. One of the solution approaches is to supply the code with different configurations, depending on whether it is run in test mode, or regular runtime mode. Goals \u00b6 We want to allow testing configurations without modifying the actual code. The simple, straightforward way would be to provide ConfigFactoryBuilder instances to your code, set up differently depending on whether testing or not. But that's breaking encapsulation, and cumbersome. Instead, we provide a way to change the ConfigFactoryBuilder behaviour for the entire VM - \"static\"-like. This way, all instances in the respective JVM are turned to test mode or production mode, including the paths and settings you also specify. This way, your test code can set the test environment in a @BeforeAll/@BeforeEach function before the tests start, while tests and code stay free of test-specific modifications in regard to mConfig. Use \u00b6 Activate Test Mode \u00b6 ConfigFactoryBuilder.setTestMode(true); or with Environment Variables, e.g. MCONFIG_RUNTIME_TEST_MODE=true (requirements for Environment Variables to have effect: 1. EnvVar source module present, 2. ALLOW_RUNTIME_FLAG set to true in the ConfigFactoryBuilder. ) Effects of Test Mode \u00b6 this will disable lookup in the regular file paths instead, use \"./src/test/config\" and \"./src/test/resources/config\" paths relative to current working directory as base paths. Resource-based configurations in src/test/resources/config/{SCOPE} take precedence over project-level test configurations in src/test/config . This is based on the standard maven test run setup, where the tests are run from one level above the src directory. - disable lookup in default network environments, if network config sources are active - enable lookup in test network environments, if available/configured. - switch JAR lookup from regular resources folder to test resources. Instead of src/main/resources/config from source, in test mode src/test/resources/config becomes the starting point for JAR-file resolution. NB: JARs rarely compile in test resources! The JAR aspect takes effect only if you are building test JARs in addition to the regular ones. Paths for Test Mode \u00b6 Below the src/test/resources/config/ directory, we check for subdirectories with the scope names in all-caps, e.g. PRODUCT, APPLICATION, USER, to allow for placement of respective contents. In the other case, we go test/.config/ COMPANY / PRODUCTNAME , to mirror such entries for production. So, activating test mode results in these directories searched for entries: Test mode search paths \u00b6 In test mode, standard OS paths are bypassed. Use explicit paths via ConfigFactoryBuilder.setFeature(ConfigFeature.TESTMODE_DIRECTORIES, List.of(\"USER:/tmp/test-user\")) or fallbacks like src/test/resources/.config/&lt;company&gt;/&lt;app&gt;/ and src/test/resources/config/{SCOPE} (resources > project configs). Scope Path Notes POLICY TESTMODE_DIRECTORIES \"POLICY:/path\" or src/test/resources/config/POLICY Highest RUNTIME src/test/resources/config/RUNTIME SESSION src/test/resources/config/SESSION USER src/test/resources/config/USER APPLICATION src/test/config/<company>/<app>/ or src/test/resources/config/APPLICATION HOST src/test/resources/config/HOST CLUSTER src/test/resources/config/CLUSTER CLOUD src/test/resources/config/CLOUD ORGANIZATION src/test/resources/config/ORGANIZATION PRODUCT src/main/resources/.config/<company>/<app>/ Lowest NB: \"COMPANY\" and \"APP\" placeholders replaced by code values. Scope dirs verbatim UPPERCASE. Resources override project configs; scopes follow enum priority (higher scopes override lower). Custom test directories \u00b6 You can provide a list of directories for TESTMODE_DIRECTORIES with their respective scope. Format: SCOPENAME \":\" PATH e.g. USER:/~developer/mylocaltest or APPLICATION:/tmp/generatedautomatedtestingdir . Multiple entries per scope are possible, and used in order. If the scope name is omitted or invalid, it defaults to RUNTIME scope. Note : In TEST_MODE , ADDITIONAL_RUNTIME_DIRECTORIES and ADDITIONAL_USER_DIRECTORIES are intentionally ignored to prevent tests from accidentally interacting with real production data. Only TESTMODE_DIRECTORIES and the default test resource locations are used. Set your own paths (legacy API for some test environments) \u00b6 ConfigFactoryBuilder.setTestConfigPaths() allows you to set multiple paths for each scope, to be used in test mode. Deprecated; use the custom test directories above. @BeforeAll void setUpTestEnvironment () { List < String > paths = List . of ( \"/my/local/fixed/config/environment\" ); ConfigFactoryBuilder . setTestMode ( true ); // activate and set defaults ConfigFactoryBuilder . setTestFilePaths ( paths ); // replace ConfigFactoryBuilder . setTestJARURIs ( null ); // turn off } Deprecated legacy API : Paths added at RUNTIME scope. Security Considerations \u00b6 To prevent accidental or malicious activation of test mode in production environments, mConfig employs a two-tier security gate system. 1.5.1 Global Static Gate ( forbidTestMode() / permitTestMode() ) \u00b6 This is a JVM-wide master switch. Calling ConfigFactoryBuilder.forbidTestMode() ensures that no code within the JVM can activate TEST_MODE , regardless of other settings. This is intended for production environments to provide a hard security boundary. 1.5.2 Instance Dynamic Gate ( PERMIT_TEST_MODE Feature) \u00b6 This is a per-builder configuration flag. It acts as a final check before an instance activates test mode. \"Productive by Default\" \u00b6 To simplify development, the PERMIT_TEST_MODE feature defaults to true . This allows developers to activate TEST_MODE using a single flag (via environment variables, system properties, or setFeature ) without needing to explicitly enable permissions in standard environments. \"Test Mode Proofing\" (Lockdown) \u00b6 Despite with the default being true , PERMIT_TEST_MODE remains an useful security tool for some situations. In a complex process where TEST_MODE might be enabled globally (e.g., via -DTEST_MODE=true ) to facilitate integration testing of some modules, a critical production-facing ConfigFactory can be locked down: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"metabit\" , \"CRITICAL_APP\" ) . setFeature ( ConfigFeature . PERMIT_TEST_MODE , false ) // Lockdown this instance . build ()) { // ... } Even if TEST_MODE is requested externally, this specific instance will remain in production mode, ensuring it never reads from src/test/resources or other untrusted test locations, like some dynamically generated test directories and -files. Activation Logic \u00b6 Test mode is only enabled if both the global gate and the instance gate allow it. The following logic is enforced during the build() process: // Test mode is only enabled if BOTH the global gate AND the instance gate allow it. if ( testModePermitted && configFactorySettings . getBoolean ( PERMIT_TEST_MODE )) { // Activation occurs if either the global trigger or instance trigger is set. if ( testModeActive || configFactorySettings . getBoolean ( TEST_MODE )) { configFactorySettings . setBoolean ( TEST_MODE , true ); } } else { // If either permission gate is closed, test mode is forced to false. configFactorySettings . setBoolean ( TEST_MODE , false ); } 1.5.3 Self-Configuration Security \u00b6 mConfig's self-configuration feature (loading mconfig.properties from the classpath) is another area where security can be tightened. If you don't want the library to automatically configure itself from classpath resources, you can disable it: ConfigFactoryBuilder . create ( \"metabit\" , \"APP\" ) . setFeature ( ConfigFeature . ENABLE_SELF_CONFIGURATION , false ) . build (); This is particularly important in security-sensitive applications to ensure that no unexpected features (like ALLOW_MCONFIG_RUNTIME_SETTINGS or TEST_MODE ) are enabled by a JAR file placed on the classpath.","title":"1.5 Test Mode"},{"location":"15_test_mode.html#15-test-mode","text":"mConfig has a test mode. This is to support software using mConfig in performing automated tests. Test mode supports: - manual tests by individual developers, - unit and integration testing, - the CI/CD pipeline test environment. One of the problems with tests is to replace the real, runtime environment with the test environment \u2013 preferably with as little residue in the actual code as possible. One of the solution approaches is to supply the code with different configurations, depending on whether it is run in test mode, or regular runtime mode.","title":"1.5 Test Mode"},{"location":"15_test_mode.html#goals","text":"We want to allow testing configurations without modifying the actual code. The simple, straightforward way would be to provide ConfigFactoryBuilder instances to your code, set up differently depending on whether testing or not. But that's breaking encapsulation, and cumbersome. Instead, we provide a way to change the ConfigFactoryBuilder behaviour for the entire VM - \"static\"-like. This way, all instances in the respective JVM are turned to test mode or production mode, including the paths and settings you also specify. This way, your test code can set the test environment in a @BeforeAll/@BeforeEach function before the tests start, while tests and code stay free of test-specific modifications in regard to mConfig.","title":"Goals"},{"location":"15_test_mode.html#use","text":"","title":"Use"},{"location":"15_test_mode.html#activate-test-mode","text":"ConfigFactoryBuilder.setTestMode(true); or with Environment Variables, e.g. MCONFIG_RUNTIME_TEST_MODE=true (requirements for Environment Variables to have effect: 1. EnvVar source module present, 2. ALLOW_RUNTIME_FLAG set to true in the ConfigFactoryBuilder. )","title":"Activate Test Mode"},{"location":"15_test_mode.html#effects-of-test-mode","text":"this will disable lookup in the regular file paths instead, use \"./src/test/config\" and \"./src/test/resources/config\" paths relative to current working directory as base paths. Resource-based configurations in src/test/resources/config/{SCOPE} take precedence over project-level test configurations in src/test/config . This is based on the standard maven test run setup, where the tests are run from one level above the src directory. - disable lookup in default network environments, if network config sources are active - enable lookup in test network environments, if available/configured. - switch JAR lookup from regular resources folder to test resources. Instead of src/main/resources/config from source, in test mode src/test/resources/config becomes the starting point for JAR-file resolution. NB: JARs rarely compile in test resources! The JAR aspect takes effect only if you are building test JARs in addition to the regular ones.","title":"Effects of Test Mode"},{"location":"15_test_mode.html#paths-for-test-mode","text":"Below the src/test/resources/config/ directory, we check for subdirectories with the scope names in all-caps, e.g. PRODUCT, APPLICATION, USER, to allow for placement of respective contents. In the other case, we go test/.config/ COMPANY / PRODUCTNAME , to mirror such entries for production. So, activating test mode results in these directories searched for entries:","title":"Paths for Test Mode"},{"location":"15_test_mode.html#test-mode-search-paths","text":"In test mode, standard OS paths are bypassed. Use explicit paths via ConfigFactoryBuilder.setFeature(ConfigFeature.TESTMODE_DIRECTORIES, List.of(\"USER:/tmp/test-user\")) or fallbacks like src/test/resources/.config/&lt;company&gt;/&lt;app&gt;/ and src/test/resources/config/{SCOPE} (resources > project configs). Scope Path Notes POLICY TESTMODE_DIRECTORIES \"POLICY:/path\" or src/test/resources/config/POLICY Highest RUNTIME src/test/resources/config/RUNTIME SESSION src/test/resources/config/SESSION USER src/test/resources/config/USER APPLICATION src/test/config/<company>/<app>/ or src/test/resources/config/APPLICATION HOST src/test/resources/config/HOST CLUSTER src/test/resources/config/CLUSTER CLOUD src/test/resources/config/CLOUD ORGANIZATION src/test/resources/config/ORGANIZATION PRODUCT src/main/resources/.config/<company>/<app>/ Lowest NB: \"COMPANY\" and \"APP\" placeholders replaced by code values. Scope dirs verbatim UPPERCASE. Resources override project configs; scopes follow enum priority (higher scopes override lower).","title":"Test mode search paths"},{"location":"15_test_mode.html#custom-test-directories","text":"You can provide a list of directories for TESTMODE_DIRECTORIES with their respective scope. Format: SCOPENAME \":\" PATH e.g. USER:/~developer/mylocaltest or APPLICATION:/tmp/generatedautomatedtestingdir . Multiple entries per scope are possible, and used in order. If the scope name is omitted or invalid, it defaults to RUNTIME scope. Note : In TEST_MODE , ADDITIONAL_RUNTIME_DIRECTORIES and ADDITIONAL_USER_DIRECTORIES are intentionally ignored to prevent tests from accidentally interacting with real production data. Only TESTMODE_DIRECTORIES and the default test resource locations are used.","title":"Custom test directories"},{"location":"15_test_mode.html#set-your-own-paths-legacy-api-for-some-test-environments","text":"ConfigFactoryBuilder.setTestConfigPaths() allows you to set multiple paths for each scope, to be used in test mode. Deprecated; use the custom test directories above. @BeforeAll void setUpTestEnvironment () { List < String > paths = List . of ( \"/my/local/fixed/config/environment\" ); ConfigFactoryBuilder . setTestMode ( true ); // activate and set defaults ConfigFactoryBuilder . setTestFilePaths ( paths ); // replace ConfigFactoryBuilder . setTestJARURIs ( null ); // turn off } Deprecated legacy API : Paths added at RUNTIME scope.","title":"Set your own paths (legacy API for some test environments)"},{"location":"15_test_mode.html#security-considerations","text":"To prevent accidental or malicious activation of test mode in production environments, mConfig employs a two-tier security gate system.","title":"Security Considerations"},{"location":"15_test_mode.html#151-global-static-gate-forbidtestmode-permittestmode","text":"This is a JVM-wide master switch. Calling ConfigFactoryBuilder.forbidTestMode() ensures that no code within the JVM can activate TEST_MODE , regardless of other settings. This is intended for production environments to provide a hard security boundary.","title":"1.5.1 Global Static Gate (forbidTestMode() / permitTestMode())"},{"location":"15_test_mode.html#152-instance-dynamic-gate-permit_test_mode-feature","text":"This is a per-builder configuration flag. It acts as a final check before an instance activates test mode.","title":"1.5.2 Instance Dynamic Gate (PERMIT_TEST_MODE Feature)"},{"location":"15_test_mode.html#productive-by-default","text":"To simplify development, the PERMIT_TEST_MODE feature defaults to true . This allows developers to activate TEST_MODE using a single flag (via environment variables, system properties, or setFeature ) without needing to explicitly enable permissions in standard environments.","title":"\"Productive by Default\""},{"location":"15_test_mode.html#test-mode-proofing-lockdown","text":"Despite with the default being true , PERMIT_TEST_MODE remains an useful security tool for some situations. In a complex process where TEST_MODE might be enabled globally (e.g., via -DTEST_MODE=true ) to facilitate integration testing of some modules, a critical production-facing ConfigFactory can be locked down: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"metabit\" , \"CRITICAL_APP\" ) . setFeature ( ConfigFeature . PERMIT_TEST_MODE , false ) // Lockdown this instance . build ()) { // ... } Even if TEST_MODE is requested externally, this specific instance will remain in production mode, ensuring it never reads from src/test/resources or other untrusted test locations, like some dynamically generated test directories and -files.","title":"\"Test Mode Proofing\" (Lockdown)"},{"location":"15_test_mode.html#activation-logic","text":"Test mode is only enabled if both the global gate and the instance gate allow it. The following logic is enforced during the build() process: // Test mode is only enabled if BOTH the global gate AND the instance gate allow it. if ( testModePermitted && configFactorySettings . getBoolean ( PERMIT_TEST_MODE )) { // Activation occurs if either the global trigger or instance trigger is set. if ( testModeActive || configFactorySettings . getBoolean ( TEST_MODE )) { configFactorySettings . setBoolean ( TEST_MODE , true ); } } else { // If either permission gate is closed, test mode is forced to false. configFactorySettings . setBoolean ( TEST_MODE , false ); }","title":"Activation Logic"},{"location":"15_test_mode.html#153-self-configuration-security","text":"mConfig's self-configuration feature (loading mconfig.properties from the classpath) is another area where security can be tightened. If you don't want the library to automatically configure itself from classpath resources, you can disable it: ConfigFactoryBuilder . create ( \"metabit\" , \"APP\" ) . setFeature ( ConfigFeature . ENABLE_SELF_CONFIGURATION , false ) . build (); This is particularly important in security-sensitive applications to ensure that no unexpected features (like ALLOW_MCONFIG_RUNTIME_SETTINGS or TEST_MODE ) are enabled by a JAR file placed on the classpath.","title":"1.5.3 Self-Configuration Security"},{"location":"21_how_it_works.html","text":"2.1 How it Works \u00b6 To get started, we need a lot of preparation and settings. These are collected in a factory builder, ConfigFactoryBuilder , which then builds a ConfigFactory with specific settings. Self-Configuration \u00b6 Before the ConfigFactory is fully operational, it may perform \"self-configuration\". If the mConfigSourceJAR module is active, the factory searches the classpath for: .config/metabit/mConfig/mconfig.properties This feature is enabled by default. It can be disabled by setting the ENABLE_SELF_CONFIGURATION flag to false in the ConfigFactoryBuilder . Settings found in this file (or files, as it uses ClassLoader.getResources() ) are used to populate the internal ConfigFactorySettings . This allows the library to configure its own features (like enabling environment variable processing via ALLOW_MCONFIG_RUNTIME_SETTINGS ) using its standard resource discovery layout. The ConfigFactory in turn produces individual Configuration objects. That's the startup phase; once that is done, you use the Configuration objects. Concept: Scopes \u00b6 mConfig uses the concept of hierarchical scopes (from the pre-2000 metabit MAUS project). The software may have its generic defaults, which can be overridden by settings of the individual local installation. But if you allow user-based settings, these take precedence over the local installation; and settings given for the individual software instance run may override those, in turn. It's a hierarchy. Scope order (lowest to highest priority): PRODUCT -> ORGANIZATION -> CLOUD -> CLUSTER -> HOST -> APPLICATION -> USER -> SESSION -> RUNTIME -> POLICY Scope meanings (short version) \u00b6 Scope Intended use Typical sources PRODUCT Defaults shipped with the software. ConfigScheme defaults, JAR resources ORGANIZATION Company-level defaults and licensing. Registry, network services CLOUD Cloud-based configurations, shared across multiple clusters. Cloud services, network services CLUSTER Cluster-wide settings. ZooKeeper, network services HOST System-wide settings for one host. Filesystem, Registry, System properties APPLICATION Installation-specific settings (portable installs, side-by-side versions). Filesystem near the binary USER Per-user overrides and preferences. Filesystem, Registry SESSION Shell/session overrides. Environment variables, command-line RUNTIME In-memory changes at runtime. RAM layer POLICY Enforced overrides (highest priority). GPO/Registry, policy files Default scope and source hierarchy \u00b6 Resolution priority between different storage types (within the same scope) is deterministic. Default Storage Priority (Highest to Lowest): 1. RAM (In-memory overrides) 2. secrets (Encrypted/sensitive data) 3. files (Local filesystem) 4. registry (Windows Registry) 5. registryjni (Windows Registry JNI) 6. zookeeper (ZooKeeper module) 7. JAR (Classpath resources/defaults) Use STORAGE_TYPE_PRIORITIES to change this order within a scope. Filesystem search paths (FileConfigStorage) \u00b6 The lists below show the default search paths as added to the search list . Earlier entries are preferred for creation ; later entries override earlier ones within the same scope. SUB_PATH (if set) is appended to the application paths. ADDITIONAL_*_DIRECTORIES are prepended to their scope lists. Optional Company Segment : <company> omitted if COMPANY_NAME blank/null/whitespace (recommended but can be intentionally left blank for app-only paths). Examples below show both forms where applicable. Linux (and most Unix-like systems) HOST scope: - $XDG_CONFIG_DIRS (default /etc/xdg ), each entry: <dir>/<app> - /etc/opt/[<company>/]<app>/<subPath> - /etc/opt/<app>/<subPath> - /usr/local/etc/<app>/<subPath> - /etc/<app>/<subPath> USER scope: - $XDG_CONFIG_HOME/[<company>/]<app>/<subPath> (if set) - ~/.config/[<company>/]<app>/<subPath> - ~/.<app>/<subPath> - SESSION scope: - $PWD/.config/<app>/<subPath> Windows SESSION scope: - %CD%\\\\.config\\\\<app>\\\\<subPath> - %CD% (legacy side-by-side .ini, .properties, etc.) USER scope: - %XDG_CONFIG_HOME%\\\\<app>\\\\<subPath> (if set) - %AppData%\\\\[<company>\\\\<]<app>\\\\<subPath> - %LocalAppData%\\\\[<company>\\\\<]<app>\\\\<subPath> - %UserProfile%\\\\.config\\\\<app>\\\\<subPath> APPLICATION scope: - <appDir>\\\\.config - <appDir> HOST scope: - %ProgramData%\\\\[<company>\\\\<]<app> - %AllUsersProfile%\\\\[<company>\\\\<]<app> macOS (experimental) USER scope: - $XDG_CONFIG_HOME/[<company>/]<app>/<subPath> (if set) - ~/Library/Application Support/[<company>/]<app>/<subPath> - ~/Library/Preferences/[<company>/]<app>/<subPath> - ~/.<app>/<subPath> HOST scope: - /Library/Application Support/[<company>/]<app>/<subPath> - /Library/Preferences/[<company>/]<app>/<subPath> APPLICATION scope: - <appDir>/.config - <appDir> SESSION scope: - $PWD/.config/<app>/<subPath> Android (experimental) APPLICATION scope: - /data/data/<app>/files/.config/<subPath> - /data/data/<app>/files/<subPath> USER scope: - /data/data/<app>/files/<subPath> - /storage/emulated/0/Android/data/<app>/files/.config/<subPath> (if EXTERNAL_STORAGE set) - /storage/emulated/0/Android/data/<app>/files/<subPath> SESSION scope: - /data/data/<app>/cache/.config/<subPath> - Plus Linux-style fallbacks. Fallback (unknown OS) USER scope: - ~/.<app>/<subPath> HOST scope: - $PWD/.config/<app>/<subPath> The Process \u00b6 Layered Stack \u00b6 When you ask for a ConfigEntry (or just its value) by providing a key, the library starts searching. The normal method is using a layered stack, sorted by the aforementioned scopes. At top, if enabled, is the cache layer, at RUNTIME scope. Below it follow the other scopes, down to the PRODUCT scope, where you can find the defaults layer. For each layer, the respective configuration source is asked whether it has an entry matching the key. The topmost layer which has a valid entry wins, and you get the ConfigEntry it has found. If you asked for just the value, not the full ConfigEntry, then the library tries to return the data found in the Java class matching the type of value you asked for (e.g. Boolean, Integer, byte array). validation \u00b6 Note the mention of valid data. You can, and should, provide a ConfigScheme which declares the expected entries, and some information about them. Mandatory for this is a key (~ name), and a type . The types match or are translated to types in the different config sources. The type is also used for initial conversion of the data. So if the type is NUMBER, then \"xyyyzy\" is not a valid value. The default behaviour is to skip such entries, but log a warning - we want to provide usable data to continue your program code with, best-effort. An optional field allows for more specific restrictions to be applied to fields, listing which contents are acceptable values. When a ConfigScheme is activated for a Configuration - it sets the DefaultLayer contents, if defaults are not disabled - it becomes available for the Configuration, to check entries against. - it also is available for documentation generation The checks are performed @TODO continue Changes & Monitoring \u00b6 There's two different aspects to changes. First, getting notifications when the value of a config entry changes. This is actively checking, even polling, for changes, to notify your code about such events. It checks across different ConfigSources, formats, and the like. mConfig provides a subscription mechanism via subscribeToUpdates(Consumer<ConfigLocation>) . This allows applications (and tools like the mconfig monitor command) to react to configuration changes in real-time. Second, the automated cache flush for some config sources. For most, reading is not much effort; but certain ones - especially files and parsing their formats - are not that cheap. So these are read, parsed, and then cached for some time. But the cache should not stay indefinitely, it needs to detect changes and/or refresh automatically. \u2192 ConfigFeature.UPDATE_CHECK_FREQUENCY_MS Behind the Scenes \u00b6 mConfig uses these concepts for separation of concerns: ConfigSource is something where configurations come from. it returns Configuration instances. ConfigStorage is a concept representing an access medium, e.g. Filesystem, OS registry, network config services. It provides the technical access. ConfigFormat is how the configuration is structured and formatted inside the access medium. Files, specifically, come in a number of different formats; this handles the actual parsing. ConfigLocation: Represents the specific path/handle (the \"Directory\" part). This is how it is supposed to be (and as of 0.6.x, isn't yet!) erDiagram Configuration }|--|| ConfigFactory : \"comes from\" ConfigFactory ||--|| ConfigSearchList : has Configuration ||--|| ConfigSearchList : uses ConfigSearchList ||--|{ ConfigSource : contains ConfigSource ||--|| ConfigLocation : \"has a specific\" ConfigSource ||--|| ConfigStorage : \"reads from\" ConfigSource ||--|| ConfigFormat : \"uses a specific\" ConfigStorage ||--|{ ConfigFormat : \"compatible with\" Configuration ||--o| ConfigScheme : \"may use\" ConfigScheme ||--o{ ConfigSchemeEntry : contains Configuration : the API interface to access configurations; produces/keeps ConfigEntry instances, and provides simple access to the values. They use their respective ConfigFactory search list, which consists of hierarchical and scoped ConfigSource entries, to get ConfigEntry instances. An Configuration object is a way to access configurations in an uniform way. ConfigSource : this is ((supposed to be)) the combined ConfigStorage+ConfigFormat tuple, instantiated, for active use. It can produce Configuration instances, which link back to it. A ConfigSource is where you can get a configurations from. ConfigStorage : Filesystem, Windows registry, Environment, networked system etc. - this provides the (potentially OS-specific) access mechanisms to wherever configurations come from. A ConfigStorage is where configurations are stored. ConfigFormat : Java-Properties, JSON, YAML, Windows registry, ... - this maps general keys to storage-specific addressing, and - performs format-specific conversions. A ConfigFormat is a format configurations are stored in. As of 0.6, there is a confusion between ConfigSource and ConfigStorage; also, the layer separation isn't clean yet. The ConfigSource would be the instance combination of several tuples; for example, using the FileConfigStorage, there would be a number of separate ConfigSource entries in the search list, each for a different directory. For the WindowsRegistryStorage, there's less of them (HKLM and so on); for the EnvironmentVariableStorage, there is probably just one. Whether ConfigSource will have different service-type instances is still open; the matching of Format and Storage is the tricky bit here. (( Should we present the available formats to the storages, ask them for compatibility? Should we do it the other way around? The interface between the two may be very specific. How to match them, and link them in a general way? )) Situation as of 0.6 flowchart LR ConfigSearchList -->|contains several| ConfigLocationImpl ConfigLocationImpl -->|adds properties to| ConfigSourceInterface ConfigLocationImpl --> location ConfigLocationImpl --> flags ConfigSourceInterface --> FileConfigSource ConfigSourceInterface --> SchemeDefaultConfigSource Planned for 0.7 flowchart LR ConfigSearchList --> ConfigSource ConfigSource --> ConfigStorage ConfigStorage -..-> ConfigFormat ConfigStorage <--> ConfigLocation Configuration --> ConfigLocation Anchor \u00b6 The ConfigFactoryBuilder gathers and combines all the settings. It creates a ConfigFactoryInstanceContext and a ConfigFactory to use it. The ConfigFactoryInstanceContext is passed to several objects the ConfigFactory uses, so they can get their respective features, settings, access to a logger, and so on - it is an internally shared resource. Security and Secrets \u00b6 mConfig has built-in support for sensitive data such as passwords, API keys, and private certificates. Secret Redaction \u00b6 Config entries marked as secrets in the ConfigScheme are automatically handled with care: - Their toString() representation is redacted ( [REDACTED] ). (using stars could be ambiguous) - They are stored in specialized SecretConfigEntryLeaf objects. - In-memory storage uses byte[] or char[] to allow for clearing the data after use. The SecretValue API \u00b6 For programmatically accessing secrets, mConfig provides the SecretValue interface. This allows retrieving the sensitive data without it being accidentally converted to a standard String that might linger in the Java String Pool. SecretValue password = config . getSecret ( \"database/password\" ); byte [] rawBytes = password . getValue (); // ... use and then potentially clear the bytes Binary Data (BLOBs) \u00b6 Not all configuration is text-based. mConfig supports Binary Large Objects (BLOBs) for things like license files, binary keys, or certificates. Hierarchical BLOBs \u00b6 In modern formats like JSON and YAML, binary data can be embedded directly. - YAML uses the standard !!binary tag. - JSON uses Base64 encoded strings. If a ConfigScheme is provided that marks a key as BYTES type, mConfig will automatically decode the Base64 string into a byte array. Flat Binary Files \u00b6 For legacy support or specific use cases, an entire file can be treated as a single binary blob. This uses the binary_file format and is accessed via the empty string key ( \"\" ). // Retrieving an entire .bin file as a single blob Configuration licenseCfg = factory . getConfig ( \"license\" ); byte [] licenseData = licenseCfg . getBytes ( \"\" ); Failure Handling \u00b6 If there is no ConfigEntry found at any layer, and no specific default is found, the reaction is determined by the ConfigFeature flags set. (a) return a generic default value depending on the type (b) throw ConfigException (runtime exception type) (c) return \"null\" as ConfigEntry handle, your own code wants to handle the details. \u2014 this will still cause an exception if you are asking for the value only. It is recommended, though, that you provide for each config entry you are reading a default value which is sensible and useful in the context of your use case.","title":"2.1 How it Works"},{"location":"21_how_it_works.html#21-how-it-works","text":"To get started, we need a lot of preparation and settings. These are collected in a factory builder, ConfigFactoryBuilder , which then builds a ConfigFactory with specific settings.","title":"2.1 How it Works"},{"location":"21_how_it_works.html#self-configuration","text":"Before the ConfigFactory is fully operational, it may perform \"self-configuration\". If the mConfigSourceJAR module is active, the factory searches the classpath for: .config/metabit/mConfig/mconfig.properties This feature is enabled by default. It can be disabled by setting the ENABLE_SELF_CONFIGURATION flag to false in the ConfigFactoryBuilder . Settings found in this file (or files, as it uses ClassLoader.getResources() ) are used to populate the internal ConfigFactorySettings . This allows the library to configure its own features (like enabling environment variable processing via ALLOW_MCONFIG_RUNTIME_SETTINGS ) using its standard resource discovery layout. The ConfigFactory in turn produces individual Configuration objects. That's the startup phase; once that is done, you use the Configuration objects.","title":"Self-Configuration"},{"location":"21_how_it_works.html#concept-scopes","text":"mConfig uses the concept of hierarchical scopes (from the pre-2000 metabit MAUS project). The software may have its generic defaults, which can be overridden by settings of the individual local installation. But if you allow user-based settings, these take precedence over the local installation; and settings given for the individual software instance run may override those, in turn. It's a hierarchy. Scope order (lowest to highest priority): PRODUCT -> ORGANIZATION -> CLOUD -> CLUSTER -> HOST -> APPLICATION -> USER -> SESSION -> RUNTIME -> POLICY","title":"Concept: Scopes"},{"location":"21_how_it_works.html#scope-meanings-short-version","text":"Scope Intended use Typical sources PRODUCT Defaults shipped with the software. ConfigScheme defaults, JAR resources ORGANIZATION Company-level defaults and licensing. Registry, network services CLOUD Cloud-based configurations, shared across multiple clusters. Cloud services, network services CLUSTER Cluster-wide settings. ZooKeeper, network services HOST System-wide settings for one host. Filesystem, Registry, System properties APPLICATION Installation-specific settings (portable installs, side-by-side versions). Filesystem near the binary USER Per-user overrides and preferences. Filesystem, Registry SESSION Shell/session overrides. Environment variables, command-line RUNTIME In-memory changes at runtime. RAM layer POLICY Enforced overrides (highest priority). GPO/Registry, policy files","title":"Scope meanings (short version)"},{"location":"21_how_it_works.html#default-scope-and-source-hierarchy","text":"Resolution priority between different storage types (within the same scope) is deterministic. Default Storage Priority (Highest to Lowest): 1. RAM (In-memory overrides) 2. secrets (Encrypted/sensitive data) 3. files (Local filesystem) 4. registry (Windows Registry) 5. registryjni (Windows Registry JNI) 6. zookeeper (ZooKeeper module) 7. JAR (Classpath resources/defaults) Use STORAGE_TYPE_PRIORITIES to change this order within a scope.","title":"Default scope and source hierarchy"},{"location":"21_how_it_works.html#filesystem-search-paths-fileconfigstorage","text":"The lists below show the default search paths as added to the search list . Earlier entries are preferred for creation ; later entries override earlier ones within the same scope. SUB_PATH (if set) is appended to the application paths. ADDITIONAL_*_DIRECTORIES are prepended to their scope lists. Optional Company Segment : <company> omitted if COMPANY_NAME blank/null/whitespace (recommended but can be intentionally left blank for app-only paths). Examples below show both forms where applicable. Linux (and most Unix-like systems) HOST scope: - $XDG_CONFIG_DIRS (default /etc/xdg ), each entry: <dir>/<app> - /etc/opt/[<company>/]<app>/<subPath> - /etc/opt/<app>/<subPath> - /usr/local/etc/<app>/<subPath> - /etc/<app>/<subPath> USER scope: - $XDG_CONFIG_HOME/[<company>/]<app>/<subPath> (if set) - ~/.config/[<company>/]<app>/<subPath> - ~/.<app>/<subPath> - SESSION scope: - $PWD/.config/<app>/<subPath> Windows SESSION scope: - %CD%\\\\.config\\\\<app>\\\\<subPath> - %CD% (legacy side-by-side .ini, .properties, etc.) USER scope: - %XDG_CONFIG_HOME%\\\\<app>\\\\<subPath> (if set) - %AppData%\\\\[<company>\\\\<]<app>\\\\<subPath> - %LocalAppData%\\\\[<company>\\\\<]<app>\\\\<subPath> - %UserProfile%\\\\.config\\\\<app>\\\\<subPath> APPLICATION scope: - <appDir>\\\\.config - <appDir> HOST scope: - %ProgramData%\\\\[<company>\\\\<]<app> - %AllUsersProfile%\\\\[<company>\\\\<]<app> macOS (experimental) USER scope: - $XDG_CONFIG_HOME/[<company>/]<app>/<subPath> (if set) - ~/Library/Application Support/[<company>/]<app>/<subPath> - ~/Library/Preferences/[<company>/]<app>/<subPath> - ~/.<app>/<subPath> HOST scope: - /Library/Application Support/[<company>/]<app>/<subPath> - /Library/Preferences/[<company>/]<app>/<subPath> APPLICATION scope: - <appDir>/.config - <appDir> SESSION scope: - $PWD/.config/<app>/<subPath> Android (experimental) APPLICATION scope: - /data/data/<app>/files/.config/<subPath> - /data/data/<app>/files/<subPath> USER scope: - /data/data/<app>/files/<subPath> - /storage/emulated/0/Android/data/<app>/files/.config/<subPath> (if EXTERNAL_STORAGE set) - /storage/emulated/0/Android/data/<app>/files/<subPath> SESSION scope: - /data/data/<app>/cache/.config/<subPath> - Plus Linux-style fallbacks. Fallback (unknown OS) USER scope: - ~/.<app>/<subPath> HOST scope: - $PWD/.config/<app>/<subPath>","title":"Filesystem search paths (FileConfigStorage)"},{"location":"21_how_it_works.html#the-process","text":"","title":"The Process"},{"location":"21_how_it_works.html#layered-stack","text":"When you ask for a ConfigEntry (or just its value) by providing a key, the library starts searching. The normal method is using a layered stack, sorted by the aforementioned scopes. At top, if enabled, is the cache layer, at RUNTIME scope. Below it follow the other scopes, down to the PRODUCT scope, where you can find the defaults layer. For each layer, the respective configuration source is asked whether it has an entry matching the key. The topmost layer which has a valid entry wins, and you get the ConfigEntry it has found. If you asked for just the value, not the full ConfigEntry, then the library tries to return the data found in the Java class matching the type of value you asked for (e.g. Boolean, Integer, byte array).","title":"Layered Stack"},{"location":"21_how_it_works.html#validation","text":"Note the mention of valid data. You can, and should, provide a ConfigScheme which declares the expected entries, and some information about them. Mandatory for this is a key (~ name), and a type . The types match or are translated to types in the different config sources. The type is also used for initial conversion of the data. So if the type is NUMBER, then \"xyyyzy\" is not a valid value. The default behaviour is to skip such entries, but log a warning - we want to provide usable data to continue your program code with, best-effort. An optional field allows for more specific restrictions to be applied to fields, listing which contents are acceptable values. When a ConfigScheme is activated for a Configuration - it sets the DefaultLayer contents, if defaults are not disabled - it becomes available for the Configuration, to check entries against. - it also is available for documentation generation The checks are performed @TODO continue","title":"validation"},{"location":"21_how_it_works.html#changes-monitoring","text":"There's two different aspects to changes. First, getting notifications when the value of a config entry changes. This is actively checking, even polling, for changes, to notify your code about such events. It checks across different ConfigSources, formats, and the like. mConfig provides a subscription mechanism via subscribeToUpdates(Consumer<ConfigLocation>) . This allows applications (and tools like the mconfig monitor command) to react to configuration changes in real-time. Second, the automated cache flush for some config sources. For most, reading is not much effort; but certain ones - especially files and parsing their formats - are not that cheap. So these are read, parsed, and then cached for some time. But the cache should not stay indefinitely, it needs to detect changes and/or refresh automatically. \u2192 ConfigFeature.UPDATE_CHECK_FREQUENCY_MS","title":"Changes &amp; Monitoring"},{"location":"21_how_it_works.html#behind-the-scenes","text":"mConfig uses these concepts for separation of concerns: ConfigSource is something where configurations come from. it returns Configuration instances. ConfigStorage is a concept representing an access medium, e.g. Filesystem, OS registry, network config services. It provides the technical access. ConfigFormat is how the configuration is structured and formatted inside the access medium. Files, specifically, come in a number of different formats; this handles the actual parsing. ConfigLocation: Represents the specific path/handle (the \"Directory\" part). This is how it is supposed to be (and as of 0.6.x, isn't yet!) erDiagram Configuration }|--|| ConfigFactory : \"comes from\" ConfigFactory ||--|| ConfigSearchList : has Configuration ||--|| ConfigSearchList : uses ConfigSearchList ||--|{ ConfigSource : contains ConfigSource ||--|| ConfigLocation : \"has a specific\" ConfigSource ||--|| ConfigStorage : \"reads from\" ConfigSource ||--|| ConfigFormat : \"uses a specific\" ConfigStorage ||--|{ ConfigFormat : \"compatible with\" Configuration ||--o| ConfigScheme : \"may use\" ConfigScheme ||--o{ ConfigSchemeEntry : contains Configuration : the API interface to access configurations; produces/keeps ConfigEntry instances, and provides simple access to the values. They use their respective ConfigFactory search list, which consists of hierarchical and scoped ConfigSource entries, to get ConfigEntry instances. An Configuration object is a way to access configurations in an uniform way. ConfigSource : this is ((supposed to be)) the combined ConfigStorage+ConfigFormat tuple, instantiated, for active use. It can produce Configuration instances, which link back to it. A ConfigSource is where you can get a configurations from. ConfigStorage : Filesystem, Windows registry, Environment, networked system etc. - this provides the (potentially OS-specific) access mechanisms to wherever configurations come from. A ConfigStorage is where configurations are stored. ConfigFormat : Java-Properties, JSON, YAML, Windows registry, ... - this maps general keys to storage-specific addressing, and - performs format-specific conversions. A ConfigFormat is a format configurations are stored in. As of 0.6, there is a confusion between ConfigSource and ConfigStorage; also, the layer separation isn't clean yet. The ConfigSource would be the instance combination of several tuples; for example, using the FileConfigStorage, there would be a number of separate ConfigSource entries in the search list, each for a different directory. For the WindowsRegistryStorage, there's less of them (HKLM and so on); for the EnvironmentVariableStorage, there is probably just one. Whether ConfigSource will have different service-type instances is still open; the matching of Format and Storage is the tricky bit here. (( Should we present the available formats to the storages, ask them for compatibility? Should we do it the other way around? The interface between the two may be very specific. How to match them, and link them in a general way? )) Situation as of 0.6 flowchart LR ConfigSearchList -->|contains several| ConfigLocationImpl ConfigLocationImpl -->|adds properties to| ConfigSourceInterface ConfigLocationImpl --> location ConfigLocationImpl --> flags ConfigSourceInterface --> FileConfigSource ConfigSourceInterface --> SchemeDefaultConfigSource Planned for 0.7 flowchart LR ConfigSearchList --> ConfigSource ConfigSource --> ConfigStorage ConfigStorage -..-> ConfigFormat ConfigStorage <--> ConfigLocation Configuration --> ConfigLocation","title":"Behind the Scenes"},{"location":"21_how_it_works.html#anchor","text":"The ConfigFactoryBuilder gathers and combines all the settings. It creates a ConfigFactoryInstanceContext and a ConfigFactory to use it. The ConfigFactoryInstanceContext is passed to several objects the ConfigFactory uses, so they can get their respective features, settings, access to a logger, and so on - it is an internally shared resource.","title":"Anchor"},{"location":"21_how_it_works.html#security-and-secrets","text":"mConfig has built-in support for sensitive data such as passwords, API keys, and private certificates.","title":"Security and Secrets"},{"location":"21_how_it_works.html#secret-redaction","text":"Config entries marked as secrets in the ConfigScheme are automatically handled with care: - Their toString() representation is redacted ( [REDACTED] ). (using stars could be ambiguous) - They are stored in specialized SecretConfigEntryLeaf objects. - In-memory storage uses byte[] or char[] to allow for clearing the data after use.","title":"Secret Redaction"},{"location":"21_how_it_works.html#the-secretvalue-api","text":"For programmatically accessing secrets, mConfig provides the SecretValue interface. This allows retrieving the sensitive data without it being accidentally converted to a standard String that might linger in the Java String Pool. SecretValue password = config . getSecret ( \"database/password\" ); byte [] rawBytes = password . getValue (); // ... use and then potentially clear the bytes","title":"The SecretValue API"},{"location":"21_how_it_works.html#binary-data-blobs","text":"Not all configuration is text-based. mConfig supports Binary Large Objects (BLOBs) for things like license files, binary keys, or certificates.","title":"Binary Data (BLOBs)"},{"location":"21_how_it_works.html#hierarchical-blobs","text":"In modern formats like JSON and YAML, binary data can be embedded directly. - YAML uses the standard !!binary tag. - JSON uses Base64 encoded strings. If a ConfigScheme is provided that marks a key as BYTES type, mConfig will automatically decode the Base64 string into a byte array.","title":"Hierarchical BLOBs"},{"location":"21_how_it_works.html#flat-binary-files","text":"For legacy support or specific use cases, an entire file can be treated as a single binary blob. This uses the binary_file format and is accessed via the empty string key ( \"\" ). // Retrieving an entire .bin file as a single blob Configuration licenseCfg = factory . getConfig ( \"license\" ); byte [] licenseData = licenseCfg . getBytes ( \"\" );","title":"Flat Binary Files"},{"location":"21_how_it_works.html#failure-handling","text":"If there is no ConfigEntry found at any layer, and no specific default is found, the reaction is determined by the ConfigFeature flags set. (a) return a generic default value depending on the type (b) throw ConfigException (runtime exception type) (c) return \"null\" as ConfigEntry handle, your own code wants to handle the details. \u2014 this will still cause an exception if you are asking for the value only. It is recommended, though, that you provide for each config entry you are reading a default value which is sensible and useful in the context of your use case.","title":"Failure Handling"},{"location":"22_priorities_and_hierarchies.html","text":"2.2 Priorities and Hierarchies \u00b6 2.2.1 Search List and Priority \u00b6 The ConfigFactory maintains an ordered Search List of locations. This order is crucial for two reasons: Finding and Creating Configurations: When looking for a configuration or creating a new one (e.g., via ConfigUtil.whereToPutMyFiles ), mConfig searches through the list and picks the first matching writeable location. Thus, entries earlier in the search list have higher priority for discovery and creation. Layered Overrides (Reading): Configurations are composed of multiple layers. Layers from more specific scopes (e.g., RUNTIME ) always override more generic scopes (e.g., SYSTEM ). Within the same scope , however, the search list determines priority: layers from locations appearing later in the search list are added later to the configuration stack and thus override layers from locations appearing earlier in the same scope.","title":"2.2 Priorities and Hierarchies"},{"location":"22_priorities_and_hierarchies.html#22-priorities-and-hierarchies","text":"","title":"2.2 Priorities and Hierarchies"},{"location":"22_priorities_and_hierarchies.html#221-search-list-and-priority","text":"The ConfigFactory maintains an ordered Search List of locations. This order is crucial for two reasons: Finding and Creating Configurations: When looking for a configuration or creating a new one (e.g., via ConfigUtil.whereToPutMyFiles ), mConfig searches through the list and picks the first matching writeable location. Thus, entries earlier in the search list have higher priority for discovery and creation. Layered Overrides (Reading): Configurations are composed of multiple layers. Layers from more specific scopes (e.g., RUNTIME ) always override more generic scopes (e.g., SYSTEM ). Within the same scope , however, the search list determines priority: layers from locations appearing later in the search list are added later to the configuration stack and thus override layers from locations appearing earlier in the same scope.","title":"2.2.1 Search List and Priority"},{"location":"23_configuration_schemes.html","text":"2.3 Configuration Schemes \u00b6 Configuration schemes define the contract for a set of configuration entries. They specify what keys are expected, their data types, default values, validation rules, and other metadata. 2.3.1 Overview \u00b6 A scheme ensures that the configuration data used by the application is valid and consistent. When a configuration is loaded (e.g., via getConfig(name) ), mConfig attempts to bind it to a matching scheme. 2.3.1.1 Benefits of using Schemes \u00b6 Validation : Automatically check if values match expected types and patterns. Defaults : Provide fallback values if none are found in any configuration layer. Documentation : Automatically generate documentation for configuration entries. Type Safety : Preserve data types (e.g., Integer, Boolean) throughout the configuration stack. Security : Identify which entries contain sensitive data (secrets). 2.3.2 Example \u00b6 Minimal example (single scheme entry with a default): [ { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 , \"DESCRIPTION\" : \"Listening port\" } ] Named scheme example (multiple entries): { \"my-app-config\" : { \"NAME\" : \"my-app-config\" , \"ENTRIES\" : [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ] } } 2.3.3 Scheme Structure \u00b6 Schemes are typically defined in JSON format. A scheme file can contain a single scheme or multiple named schemes. 2.3.3.1 Scheme Entry Properties \u00b6 Each entry in a scheme (within the ENTRIES list) can have the following properties: Property Type Description KEY String The hierarchical path of the entry (e.g., database/host ). TYPE String The data type: STRING , NUMBER , BOOLEAN , BYTES , MULTIPLE_STRINGS , ENUM , ENUM_SET , URI , FILEPATH , DATE , TIME , DATETIME . DESCRIPTION String Human-readable description or Resource Bundle key for localized description. (Optional) DEFAULT (any) The default value used if no other value is provided. (Optional) PATTERN String A validation pattern (Regex, range specification, or enum list). (Optional) SECRET Boolean If true , the entry is treated as sensitive data (redacted in logs). (Optional, defaults to false ) HIDDEN Boolean If true , the entry is hidden from automatic documentation. (Optional, defaults to false ) ARITY String The number of allowed occurrences (e.g., 1 , 0..1 , 1..* ). (Optional; see defaults below) MANDATORY Object (Optional) Block for future-proofing and strict requirements. See below. AFTER String (Optional) For temporal types, value must be after this (ISO format or now ). BEFORE String (Optional) For temporal types, value must be before this (ISO format or now ). REQUIRE_OFFSET Boolean (Optional) For DATETIME , requires an offset (e.g., +02:00 or Z ). 2.3.3.2 Arity ( ARITY ) \u00b6 The ARITY property defines the constraints on the number of elements for an entry. This is especially useful for MULTIPLE_STRINGS and ENUM_SET types. Exact number : \"ARITY\": \"3\" (exactly 3 items required). Range : \"ARITY\": \"1..5\" (minimum 1, maximum 5 items). Open-ended : \"ARITY\": \"1..*\" or \"ARITY\": \"1..n\" (at least 1 item, no upper limit). Defaults : Mandatory entries: 1 Optional entries: 0..1 List types ( MULTIPLE_STRINGS , ENUM_SET ): 0..* (optional) or 1..* (mandatory). 2.3.3.3 Validation Patterns ( PATTERN ) \u00b6 Validation patterns depend on the TYPE of the entry: STRING : A Java Regular Expression. Compiled with Pattern.UNICODE_CHARACTER_CLASS by default, supporting Unicode property escapes like \\p{L} . NUMBER : Mathematical Interval Notation : Supports [min, max] , (min, max) , [min, max) , and (min, max] . Example: [1024, 65535] . Predefined Aliases : Unsigned: uint8 (0-255), uint16 , uint32 , uint64 . Signed: int8 (-128 to 127), int16 , int32 , int64 , and custom bit-widths like int7 , int15 , int31 , int63 . ENUM / ENUM_SET : A pipe-separated list of valid options. Example: DEBUG|INFO|WARN|ERROR . URI : A valid URI string (RFC 3986). FILEPATH : A valid path on the filesystem. Path Validation Flags : Can be placed inside the MANDATORY block for semantic checks: EXISTS : true (path must exist) IS_DIRECTORY : true (path must be a directory) IS_FILE : true (path must be a regular file) CAN_WRITE : true (path must be writable) DATE / TIME / DATETIME : Temporal types in ISO-8601 format. Temporal Validation Flags : Can be used directly or inside MANDATORY : AFTER : Value must be chronologically after this (e.g., \"2020-01-01\" , \"now\" ). BEFORE : Value must be chronologically before this. REQUIRE_OFFSET : (For DATETIME only) If true , requires the presence of a time zone offset (e.g., +05:00 or Z ). 2.3.3.4 Internationalization (I18N) \u00b6 The DESCRIPTION property can be a plain string or a key in a Resource Bundle. - mConfig looks for Resource Bundles named messages in the same locations as schemes (e.g., .config/messages.properties ). - If a matching key is found in the bundle for the current locale (configured via ConfigFeature.PREFERRED_LANGUAGE ), the localized string is used. - Otherwise, the raw DESCRIPTION string is used as a fallback. 2.3.4 ConfigSchemeFactory \u00b6 For 1.0 and better multi-language support (JNI/Rust/Python), use ConfigSchemeFactory to create schemes and entries programmatically: ConfigSchemeFactory factory = ConfigSchemeFactory . create (); ConfigScheme scheme = factory . createScheme (); ConfigSchemeEntry entry = factory . createEntry ( \"port\" , ConfigEntryType . NUMBER ) . setValidationPattern ( \"uint16\" ) . setDefault ( \"8080\" ); scheme . addSchemeEntry ( entry ); 2.3.5 Future-Proofing with the MANDATORY block \u00b6 To ensure that future extensions to the scheme format do not break older versions of the library, or conversely, that newer schemes can demand features that older versions must respect, mConfig uses a MANDATORY sub-item. If a scheme entry contains a MANDATORY block, the library MUST understand all keys within that block. If any key inside MANDATORY is unknown to the current version of mConfig, the scheme loading will fail with an UNKNOWN_MANDATORY_FEATURE error. Example: { \"KEY\" : \"network/timeout\" , \"TYPE\" : \"NUMBER\" , \"MANDATORY\" : { \"UNIT\" : \"milliseconds\" } } In this example, if a future version of mConfig introduces a UNIT feature and it's placed inside MANDATORY , an older version that doesn't know about UNIT will refuse to load the scheme, preventing potential misconfiguration (e.g., interpreting milliseconds as seconds). Features outside the MANDATORY block that are unknown to the library are silently ignored. 2.3.6 Formats \u00b6 mConfig supports several JSON structures for defining schemes: 2.3.6.1 Named Scheme Object \u00b6 { \"my-app-config\" : { \"NAME\" : \"my-app-config\" , \"ENTRIES\" : [ { \"KEY\" : \"port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ] } } 2.3.6.2 List of Entries (Anonymous Scheme) \u00b6 If a JSON file contains only a list of entries, it is treated as a scheme for the configuration matching the filename (excluding .scheme.json ). [ { \"KEY\" : \"port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ] 2.3.7 Discovery \u00b6 Schemes are automatically discovered from the classpath within .config/ directories. - Filenames should follow the pattern name.scheme.json . - Schemes can also be provided manually via ConfigFactoryBuilder.setSchemes() . - Discovered schemes are registered in the ConfigSchemeRepository . Developer Notes \u00b6 For internals/parsing/validation details, see project devdocs/config_schemes_internals.md (not included in public docs).","title":"2.3 Configuration Schemes"},{"location":"23_configuration_schemes.html#23-configuration-schemes","text":"Configuration schemes define the contract for a set of configuration entries. They specify what keys are expected, their data types, default values, validation rules, and other metadata.","title":"2.3 Configuration Schemes"},{"location":"23_configuration_schemes.html#231-overview","text":"A scheme ensures that the configuration data used by the application is valid and consistent. When a configuration is loaded (e.g., via getConfig(name) ), mConfig attempts to bind it to a matching scheme.","title":"2.3.1 Overview"},{"location":"23_configuration_schemes.html#2311-benefits-of-using-schemes","text":"Validation : Automatically check if values match expected types and patterns. Defaults : Provide fallback values if none are found in any configuration layer. Documentation : Automatically generate documentation for configuration entries. Type Safety : Preserve data types (e.g., Integer, Boolean) throughout the configuration stack. Security : Identify which entries contain sensitive data (secrets).","title":"2.3.1.1 Benefits of using Schemes"},{"location":"23_configuration_schemes.html#232-example","text":"Minimal example (single scheme entry with a default): [ { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 , \"DESCRIPTION\" : \"Listening port\" } ] Named scheme example (multiple entries): { \"my-app-config\" : { \"NAME\" : \"my-app-config\" , \"ENTRIES\" : [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ] } }","title":"2.3.2 Example"},{"location":"23_configuration_schemes.html#233-scheme-structure","text":"Schemes are typically defined in JSON format. A scheme file can contain a single scheme or multiple named schemes.","title":"2.3.3 Scheme Structure"},{"location":"23_configuration_schemes.html#2331-scheme-entry-properties","text":"Each entry in a scheme (within the ENTRIES list) can have the following properties: Property Type Description KEY String The hierarchical path of the entry (e.g., database/host ). TYPE String The data type: STRING , NUMBER , BOOLEAN , BYTES , MULTIPLE_STRINGS , ENUM , ENUM_SET , URI , FILEPATH , DATE , TIME , DATETIME . DESCRIPTION String Human-readable description or Resource Bundle key for localized description. (Optional) DEFAULT (any) The default value used if no other value is provided. (Optional) PATTERN String A validation pattern (Regex, range specification, or enum list). (Optional) SECRET Boolean If true , the entry is treated as sensitive data (redacted in logs). (Optional, defaults to false ) HIDDEN Boolean If true , the entry is hidden from automatic documentation. (Optional, defaults to false ) ARITY String The number of allowed occurrences (e.g., 1 , 0..1 , 1..* ). (Optional; see defaults below) MANDATORY Object (Optional) Block for future-proofing and strict requirements. See below. AFTER String (Optional) For temporal types, value must be after this (ISO format or now ). BEFORE String (Optional) For temporal types, value must be before this (ISO format or now ). REQUIRE_OFFSET Boolean (Optional) For DATETIME , requires an offset (e.g., +02:00 or Z ).","title":"2.3.3.1 Scheme Entry Properties"},{"location":"23_configuration_schemes.html#2332-arity-arity","text":"The ARITY property defines the constraints on the number of elements for an entry. This is especially useful for MULTIPLE_STRINGS and ENUM_SET types. Exact number : \"ARITY\": \"3\" (exactly 3 items required). Range : \"ARITY\": \"1..5\" (minimum 1, maximum 5 items). Open-ended : \"ARITY\": \"1..*\" or \"ARITY\": \"1..n\" (at least 1 item, no upper limit). Defaults : Mandatory entries: 1 Optional entries: 0..1 List types ( MULTIPLE_STRINGS , ENUM_SET ): 0..* (optional) or 1..* (mandatory).","title":"2.3.3.2 Arity (ARITY)"},{"location":"23_configuration_schemes.html#2333-validation-patterns-pattern","text":"Validation patterns depend on the TYPE of the entry: STRING : A Java Regular Expression. Compiled with Pattern.UNICODE_CHARACTER_CLASS by default, supporting Unicode property escapes like \\p{L} . NUMBER : Mathematical Interval Notation : Supports [min, max] , (min, max) , [min, max) , and (min, max] . Example: [1024, 65535] . Predefined Aliases : Unsigned: uint8 (0-255), uint16 , uint32 , uint64 . Signed: int8 (-128 to 127), int16 , int32 , int64 , and custom bit-widths like int7 , int15 , int31 , int63 . ENUM / ENUM_SET : A pipe-separated list of valid options. Example: DEBUG|INFO|WARN|ERROR . URI : A valid URI string (RFC 3986). FILEPATH : A valid path on the filesystem. Path Validation Flags : Can be placed inside the MANDATORY block for semantic checks: EXISTS : true (path must exist) IS_DIRECTORY : true (path must be a directory) IS_FILE : true (path must be a regular file) CAN_WRITE : true (path must be writable) DATE / TIME / DATETIME : Temporal types in ISO-8601 format. Temporal Validation Flags : Can be used directly or inside MANDATORY : AFTER : Value must be chronologically after this (e.g., \"2020-01-01\" , \"now\" ). BEFORE : Value must be chronologically before this. REQUIRE_OFFSET : (For DATETIME only) If true , requires the presence of a time zone offset (e.g., +05:00 or Z ).","title":"2.3.3.3 Validation Patterns (PATTERN)"},{"location":"23_configuration_schemes.html#2334-internationalization-i18n","text":"The DESCRIPTION property can be a plain string or a key in a Resource Bundle. - mConfig looks for Resource Bundles named messages in the same locations as schemes (e.g., .config/messages.properties ). - If a matching key is found in the bundle for the current locale (configured via ConfigFeature.PREFERRED_LANGUAGE ), the localized string is used. - Otherwise, the raw DESCRIPTION string is used as a fallback.","title":"2.3.3.4 Internationalization (I18N)"},{"location":"23_configuration_schemes.html#234-configschemefactory","text":"For 1.0 and better multi-language support (JNI/Rust/Python), use ConfigSchemeFactory to create schemes and entries programmatically: ConfigSchemeFactory factory = ConfigSchemeFactory . create (); ConfigScheme scheme = factory . createScheme (); ConfigSchemeEntry entry = factory . createEntry ( \"port\" , ConfigEntryType . NUMBER ) . setValidationPattern ( \"uint16\" ) . setDefault ( \"8080\" ); scheme . addSchemeEntry ( entry );","title":"2.3.4 ConfigSchemeFactory"},{"location":"23_configuration_schemes.html#235-future-proofing-with-the-mandatory-block","text":"To ensure that future extensions to the scheme format do not break older versions of the library, or conversely, that newer schemes can demand features that older versions must respect, mConfig uses a MANDATORY sub-item. If a scheme entry contains a MANDATORY block, the library MUST understand all keys within that block. If any key inside MANDATORY is unknown to the current version of mConfig, the scheme loading will fail with an UNKNOWN_MANDATORY_FEATURE error. Example: { \"KEY\" : \"network/timeout\" , \"TYPE\" : \"NUMBER\" , \"MANDATORY\" : { \"UNIT\" : \"milliseconds\" } } In this example, if a future version of mConfig introduces a UNIT feature and it's placed inside MANDATORY , an older version that doesn't know about UNIT will refuse to load the scheme, preventing potential misconfiguration (e.g., interpreting milliseconds as seconds). Features outside the MANDATORY block that are unknown to the library are silently ignored.","title":"2.3.5 Future-Proofing with the MANDATORY block"},{"location":"23_configuration_schemes.html#236-formats","text":"mConfig supports several JSON structures for defining schemes:","title":"2.3.6 Formats"},{"location":"23_configuration_schemes.html#2361-named-scheme-object","text":"{ \"my-app-config\" : { \"NAME\" : \"my-app-config\" , \"ENTRIES\" : [ { \"KEY\" : \"port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ] } }","title":"2.3.6.1 Named Scheme Object"},{"location":"23_configuration_schemes.html#2362-list-of-entries-anonymous-scheme","text":"If a JSON file contains only a list of entries, it is treated as a scheme for the configuration matching the filename (excluding .scheme.json ). [ { \"KEY\" : \"port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 } ]","title":"2.3.6.2 List of Entries (Anonymous Scheme)"},{"location":"23_configuration_schemes.html#237-discovery","text":"Schemes are automatically discovered from the classpath within .config/ directories. - Filenames should follow the pattern name.scheme.json . - Schemes can also be provided manually via ConfigFactoryBuilder.setSchemes() . - Discovered schemes are registered in the ConfigSchemeRepository .","title":"2.3.7 Discovery"},{"location":"23_configuration_schemes.html#developer-notes","text":"For internals/parsing/validation details, see project devdocs/config_schemes_internals.md (not included in public docs).","title":"Developer Notes"},{"location":"24_comment_handling.html","text":"2.4 Comment Handling in mConfig \u00b6 Of the possible configuration sources, files are the ones that support comments. Comments in configuration files are an important source of information for users. They can be used to explain configuration options, document decisions, provide context, or include relevant links. mConfig aims to keep comments intact in configuration files to ensure that human-readable information is not lost during programmatic updates. Core Principles \u00b6 Write-Preservation : Writing to a configuration file should not erase existing comments. Read-Write Symmetry : Maintaining the original structure and documentation of the file is a priority. Human-Centric : Comments are for humans. They should not be used for machine processing or \"shebang\" style logic. Programmatic Comments \u00b6 While mConfig prioritizes preserving existing comments, it also supports adding comments programmatically: Description from Scheme : When an entry is first created, mConfig can automatically include the description defined in the ConfigScheme as a comment. This is controlled by the ConfigFeature.DESCRIPTION_ON_CREATE feature. Explicit Comments : Developers can add comments to a ConfigEntry using the setComment(String) method. This is useful for documenting automated changes (e.g., \"# AUTO-REDUCED: Disk space was below 5%\"). Configuration Features \u00b6 The behavior of comment handling is governed by several ConfigFeature flags: ConfigFeature.COMMENTS_WRITING (default: false ): When set to true , mConfig will write programmatic comments to the configuration. Even when false , the library still attempts to preserve existing comments for supported formats. ConfigFeature.COMMENTS_READING (default: false ): Enables reading comments from files into the ConfigEntry objects. Note that determining exactly which lines belong to which key is heuristic-based and may not be perfect for all formats. ConfigFeature.DESCRIPTION_ON_CREATE (default: false ): When true , uses the description field from the ConfigSchemeEntry to populate comments for new entries. Format Support Matrix \u00b6 Preservation of comments depends on the underlying format module. Some high-level libraries (like Jackson) may strip comments by design. File Format mConfig Module Preserve Comments .properties mConfigFormatJavaProperties Yes INI mConfigFormatINI Yes TOML mConfigFormatTOML Yes YAML mConfigFormatYAMLwithSnakeYAML Partially TOML mConfigFormatTOMLwithJackson No YAML mConfigFormatYAMLwithJackson No JSON mConfigFormatJSONwithJackson No JSON5 mConfigFormatJSONwithJackson No Implementation Details \u00b6 Multi-line Comments \u00b6 Representation : Represented as a single String with \\n line separators. Markers : On reading, format-specific markers (e.g., # , ! , ; ) are preserved. Writing : mConfig ensures each line is correctly prefixed with the format's primary marker if it's missing. Heuristics and Association \u00b6 Leading Comments : Consecutive comment lines immediately preceding a key are associated with that key. Global Headers : Comment blocks at the top of a file (or between entries) separated by empty lines are treated as \"Global Headers\". They are preserved and rewritten at the top of the file but are not attached to any specific ConfigEntry . Inline Comments : Comments on the same line as a value are appended to the entry's comment string on a best-effort basis. Priority and Merging \u00b6 When writing an entry, comments are merged based on the following priority (top to bottom): 1. Description from Scheme : If DESCRIPTION_ON_CREATE=true and the entry is new. 2. Existing Comments : Preserved from the original file. 3. Programmatic Comments : Added via ConfigEntry.setComment() . Duplicate lines are automatically filtered during the merge process.","title":"2.4 Comment Handling"},{"location":"24_comment_handling.html#24-comment-handling-in-mconfig","text":"Of the possible configuration sources, files are the ones that support comments. Comments in configuration files are an important source of information for users. They can be used to explain configuration options, document decisions, provide context, or include relevant links. mConfig aims to keep comments intact in configuration files to ensure that human-readable information is not lost during programmatic updates.","title":"2.4 Comment Handling in mConfig"},{"location":"24_comment_handling.html#core-principles","text":"Write-Preservation : Writing to a configuration file should not erase existing comments. Read-Write Symmetry : Maintaining the original structure and documentation of the file is a priority. Human-Centric : Comments are for humans. They should not be used for machine processing or \"shebang\" style logic.","title":"Core Principles"},{"location":"24_comment_handling.html#programmatic-comments","text":"While mConfig prioritizes preserving existing comments, it also supports adding comments programmatically: Description from Scheme : When an entry is first created, mConfig can automatically include the description defined in the ConfigScheme as a comment. This is controlled by the ConfigFeature.DESCRIPTION_ON_CREATE feature. Explicit Comments : Developers can add comments to a ConfigEntry using the setComment(String) method. This is useful for documenting automated changes (e.g., \"# AUTO-REDUCED: Disk space was below 5%\").","title":"Programmatic Comments"},{"location":"24_comment_handling.html#configuration-features","text":"The behavior of comment handling is governed by several ConfigFeature flags: ConfigFeature.COMMENTS_WRITING (default: false ): When set to true , mConfig will write programmatic comments to the configuration. Even when false , the library still attempts to preserve existing comments for supported formats. ConfigFeature.COMMENTS_READING (default: false ): Enables reading comments from files into the ConfigEntry objects. Note that determining exactly which lines belong to which key is heuristic-based and may not be perfect for all formats. ConfigFeature.DESCRIPTION_ON_CREATE (default: false ): When true , uses the description field from the ConfigSchemeEntry to populate comments for new entries.","title":"Configuration Features"},{"location":"24_comment_handling.html#format-support-matrix","text":"Preservation of comments depends on the underlying format module. Some high-level libraries (like Jackson) may strip comments by design. File Format mConfig Module Preserve Comments .properties mConfigFormatJavaProperties Yes INI mConfigFormatINI Yes TOML mConfigFormatTOML Yes YAML mConfigFormatYAMLwithSnakeYAML Partially TOML mConfigFormatTOMLwithJackson No YAML mConfigFormatYAMLwithJackson No JSON mConfigFormatJSONwithJackson No JSON5 mConfigFormatJSONwithJackson No","title":"Format Support Matrix"},{"location":"24_comment_handling.html#implementation-details","text":"","title":"Implementation Details"},{"location":"24_comment_handling.html#multi-line-comments","text":"Representation : Represented as a single String with \\n line separators. Markers : On reading, format-specific markers (e.g., # , ! , ; ) are preserved. Writing : mConfig ensures each line is correctly prefixed with the format's primary marker if it's missing.","title":"Multi-line Comments"},{"location":"24_comment_handling.html#heuristics-and-association","text":"Leading Comments : Consecutive comment lines immediately preceding a key are associated with that key. Global Headers : Comment blocks at the top of a file (or between entries) separated by empty lines are treated as \"Global Headers\". They are preserved and rewritten at the top of the file but are not attached to any specific ConfigEntry . Inline Comments : Comments on the same line as a value are appended to the entry's comment string on a best-effort basis.","title":"Heuristics and Association"},{"location":"24_comment_handling.html#priority-and-merging","text":"When writing an entry, comments are merged based on the following priority (top to bottom): 1. Description from Scheme : If DESCRIPTION_ON_CREATE=true and the entry is new. 2. Existing Comments : Preserved from the original file. 3. Programmatic Comments : Added via ConfigEntry.setComment() . Duplicate lines are automatically filtered during the merge process.","title":"Priority and Merging"},{"location":"25_config_features.html","text":"2.5 Config Features \u00b6 ConfigFeature flags tune how a ConfigFactory is built and how it behaves. Set them on the ConfigFactoryBuilder before calling build() . Example: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . ALLOW_MCONFIG_RUNTIME_SETTINGS , true ) . setFeature ( ConfigFeature . DEFAULT_ON_MISSING_ENTRY , true ) . setFeature ( ConfigFeature . ADDITIONAL_USER_DIRECTORIES , List . of ( \"/opt/acme/overrides\" )); Notes: - Booleans default to false unless a default is explicitly listed below. - Some features are only used when the corresponding module is on the classpath (e.g., ZooKeeper, Registry, Secrets, JAR). - Runtime environment variables can override a subset of settings if ALLOW_MCONFIG_RUNTIME_SETTINGS is enabled. See \"Runtime overrides\" below. Runtime overrides \u00b6 If ALLOW_MCONFIG_RUNTIME_SETTINGS is set to true , mConfig accepts runtime settings via environment variables with the prefix MCONFIG_RUNTIME_ : MCONFIG_RUNTIME_DEBUG_LEVEL -> LOGLEVEL_NUMBER (accepts numbers or: off , error , warn , info , debug , trace ) MCONFIG_RUNTIME_DEBUG_OUTPUT -> LOGGING_REDIRECT_TARGET MCONFIG_RUNTIME_DISABLE_MODULES -> DISABLED_MODULE_IDS (comma-separated) MCONFIG_RUNTIME_MODULES -> ADDITIONAL_MODULE_PATHS (comma-separated) MCONFIG_RUNTIME_TEST_MODE -> TEST_MODE Feature reference \u00b6 Test mode \u00b6 PERMIT_TEST_MODE (Boolean, default: true): Master gate for test mode usage. TEST_MODE (Boolean, default: false): Activate test-mode search locations. TESTMODE_DIRECTORIES ( List<String> , default: empty): Scoped paths in SCOPE:PATH format. TESTMODE_PARAMETERS ( Map<String,String> ): Additional test parameters. Logging \u00b6 QUIET (Boolean, default: false): Reduce internal mConfig logging. LOGGING_TO_USE_IN_CONFIGLIB (String, default: \"\"): Force a specific logging module. LOGLEVEL_NUMBER (Integer, default: 4): Numeric log level for basic loggers. LOGGING_REDIRECT_TARGET (String): Redirect internal logging ( stderr , stdout , quiet , file:<path> ). Filesystem and registry paths \u00b6 ADDITIONAL_RUNTIME_DIRECTORIES ( List<String> ): Extra filesystem directories (prepended) for RUNTIME scope. ADDITIONAL_USER_DIRECTORIES ( List<String> ): Extra filesystem directories (prepended) for USER scope. REGISTRY_BASE_PATH ( String ): Registry root path (default Software/[<company>/]<application> ; omits company if blank). FILENAME_EXTENSION_MAPPINGS ( List<String> ): Extra filename extensions to try when reading config files. DEFAULT_TEXTFILE_CHARSET ( String , default: UTF-8 ): Charset for text formats. TRIM_TEXTVALUE_SPACES (Boolean, default: true): Trim leading/trailing spaces in text values. WRITE_CONDENSED_FORMAT (Boolean, default: false): Prefer compact output when writing text formats. Format priorities \u00b6 FILE_FORMAT_READING_PRIORITIES ( List<String> , default: DHALL,TOML,YAML,JSON5,JSON,ASN1,properties,INI ): Read order. FILE_FORMAT_WRITING_PRIORITIES ( List<String> , default: TOML,YAML,JSON5,JSON,properties ): Write order. FILE_FORMAT_READING_ALLOW_ALL_FORMATS (Boolean, default: true): Fallback to non-listed formats. FILE_FORMAT_WRITING_ALLOW_ALL_FORMATS (Boolean, default: true): Fallback to non-listed formats. Storage type priorities \u00b6 STORAGE_TYPE_PRIORITIES ( List<String> , default: RAM,secrets,files,registry,registryjni,zookeeper,JAR ): Init/search order within a scope. STORAGE_TYPE_ALLOW_ALL_STORAGES (Boolean, default: true): Allow storages not explicitly listed. Schemes and defaults \u00b6 CONFIG_SCHEME_LIST ( Map<String,ConfigScheme> ): Provide schemes programmatically. SCHEME_STRICT_MODE (Boolean, default: false): Reject keys not in the scheme. SCHEME_RESETS_DEFAULTS (Boolean, default: false): Replace existing defaults instead of merging. FREE_CONFIGURATION (Boolean): Allow configs without a scheme (behavior may evolve). Missing entry behavior \u00b6 EXCEPTION_ON_MISSING_ENTRY (Boolean, default: true): Throw when a key is absent. DEFAULT_ON_MISSING_ENTRY (Boolean, default: false): Return scheme defaults if missing (requires exceptions disabled). EXCEPTION_WHEN_CONFIGURATION_NOT_FOUND (Boolean, default: false): Throw if a configuration name is not found at all. FALLBACKS_ACROSS_SCOPES (Boolean, default: true): Allow fallback to less specific scopes on reads. WRITE_FALLBACK_ACROSS_SCOPES (Boolean, default: false): Allow fallback to more specific scopes on writes. Cache and update checks \u00b6 UPDATE_CHECK_FREQUENCY_MS (Integer, default: 2000): Polling interval for cached sources. UPDATE_CHECK_SCOPES ( List<String> , default: all scopes): Limit update checks by scope. CACHE_CONFIGS (Boolean): Cache configurations in memory (experimental). AUTOMATIC_CONFIG_LOADING (Boolean): Auto-load configs before first read (experimental). AUTOMATIC_CONFIG_CREATION (Boolean): Auto-create configs on write (experimental). WRITE_SYNC (Boolean): Sync writes immediately (storage-dependent). NO_DEFAULT_DIRECTORIES (Boolean): Disable default filesystem paths (experimental). Modules and runtime configuration \u00b6 ALLOW_MCONFIG_RUNTIME_SETTINGS (Boolean, default: false): Allow MCONFIG_RUNTIME_* env overrides. ENABLE_SELF_CONFIGURATION (Boolean, default: true): Allow classpath self-configuration. ADDITIONAL_MODULE_PATHS ( List<String> ): Add module IDs/paths during discovery. DISABLED_MODULE_IDS ( List<String> ): Disable specific module IDs. Secrets providers (mConfigSecrets) \u00b6 SECRETS_PROVIDER_ID (String): Primary provider ID. SECRETS_PROVIDER_CONFIG ( Map<String,Object> ): Provider configuration. ADDITIONAL_SECRETS_PROVIDERS ( List<Map<String,Object>> ): Additional providers with optional scope. ZooKeeper (mConfigSourceZooKeeper) \u00b6 ZOOKEEPER_CONNECT_STRING (String): Connection string. ZOOKEEPER_ROOT_PATH (String, default: /mconfig ): Root path. ZOOKEEPER_SESSION_TIMEOUT_MS (Integer, default: 60000): Session timeout. ZOOKEEPER_RETRY_BASE_SLEEP_MS (Integer, default: 1000): Retry base sleep. ZOOKEEPER_RETRY_MAX_RETRIES (Integer, default: 3): Retry count. ZOOKEEPER_BOOTSTRAP_CONFIG_NAME (String, default: zookeeper ): Bootstrap config name. Class loading \u00b6 USE_CONTEXT_CLASS_LOADER (Boolean, default: false): Prefer thread context loader. USE_SYSTEM_CLASS_LOADER (Boolean, default: false): Prefer system class loader. Identity and context \u00b6 COMPANY_NAME (String, optional): Company/organization name used in OS paths. Blank/null/whitespace intentionally omits the company segment across all sources. APPLICATION_NAME (String, required): Application name used in OS paths. SUB_PATH (String, optional): Sub-path appended to application paths (e.g. \"profile/tenantA\" ). CURRENT_USER_ID (String, default: OS user): User ID for the current process. CURRENT_PLATFORM_OS (OperatingSystem, auto-detected): Detected OS family. HOSTNAME (String, auto-detected): Hostname of the current machine/container. These are automatically set by the library; they are available as a ConfigFeature so you can override them if needed. Patterns to avoid boilerplate \u00b6 Missing values: prefer EXCEPTION_ON_MISSING_ENTRY=false and DEFAULT_ON_MISSING_ENTRY=true over manual try/catch or null wrapping. Strict config contracts: set SCHEME_STRICT_MODE=true instead of filtering keys by hand. Default overrides: use SCHEME_RESETS_DEFAULTS or STORAGE_TYPE_PRIORITIES rather than manual \"merge\" code. Scope behavior: use FALLBACKS_ACROSS_SCOPES and WRITE_FALLBACK_ACROSS_SCOPES instead of explicit scope iteration.","title":"2.5 Config Features"},{"location":"25_config_features.html#25-config-features","text":"ConfigFeature flags tune how a ConfigFactory is built and how it behaves. Set them on the ConfigFactoryBuilder before calling build() . Example: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . ALLOW_MCONFIG_RUNTIME_SETTINGS , true ) . setFeature ( ConfigFeature . DEFAULT_ON_MISSING_ENTRY , true ) . setFeature ( ConfigFeature . ADDITIONAL_USER_DIRECTORIES , List . of ( \"/opt/acme/overrides\" )); Notes: - Booleans default to false unless a default is explicitly listed below. - Some features are only used when the corresponding module is on the classpath (e.g., ZooKeeper, Registry, Secrets, JAR). - Runtime environment variables can override a subset of settings if ALLOW_MCONFIG_RUNTIME_SETTINGS is enabled. See \"Runtime overrides\" below.","title":"2.5 Config Features"},{"location":"25_config_features.html#runtime-overrides","text":"If ALLOW_MCONFIG_RUNTIME_SETTINGS is set to true , mConfig accepts runtime settings via environment variables with the prefix MCONFIG_RUNTIME_ : MCONFIG_RUNTIME_DEBUG_LEVEL -> LOGLEVEL_NUMBER (accepts numbers or: off , error , warn , info , debug , trace ) MCONFIG_RUNTIME_DEBUG_OUTPUT -> LOGGING_REDIRECT_TARGET MCONFIG_RUNTIME_DISABLE_MODULES -> DISABLED_MODULE_IDS (comma-separated) MCONFIG_RUNTIME_MODULES -> ADDITIONAL_MODULE_PATHS (comma-separated) MCONFIG_RUNTIME_TEST_MODE -> TEST_MODE","title":"Runtime overrides"},{"location":"25_config_features.html#feature-reference","text":"","title":"Feature reference"},{"location":"25_config_features.html#test-mode","text":"PERMIT_TEST_MODE (Boolean, default: true): Master gate for test mode usage. TEST_MODE (Boolean, default: false): Activate test-mode search locations. TESTMODE_DIRECTORIES ( List<String> , default: empty): Scoped paths in SCOPE:PATH format. TESTMODE_PARAMETERS ( Map<String,String> ): Additional test parameters.","title":"Test mode"},{"location":"25_config_features.html#logging","text":"QUIET (Boolean, default: false): Reduce internal mConfig logging. LOGGING_TO_USE_IN_CONFIGLIB (String, default: \"\"): Force a specific logging module. LOGLEVEL_NUMBER (Integer, default: 4): Numeric log level for basic loggers. LOGGING_REDIRECT_TARGET (String): Redirect internal logging ( stderr , stdout , quiet , file:<path> ).","title":"Logging"},{"location":"25_config_features.html#filesystem-and-registry-paths","text":"ADDITIONAL_RUNTIME_DIRECTORIES ( List<String> ): Extra filesystem directories (prepended) for RUNTIME scope. ADDITIONAL_USER_DIRECTORIES ( List<String> ): Extra filesystem directories (prepended) for USER scope. REGISTRY_BASE_PATH ( String ): Registry root path (default Software/[<company>/]<application> ; omits company if blank). FILENAME_EXTENSION_MAPPINGS ( List<String> ): Extra filename extensions to try when reading config files. DEFAULT_TEXTFILE_CHARSET ( String , default: UTF-8 ): Charset for text formats. TRIM_TEXTVALUE_SPACES (Boolean, default: true): Trim leading/trailing spaces in text values. WRITE_CONDENSED_FORMAT (Boolean, default: false): Prefer compact output when writing text formats.","title":"Filesystem and registry paths"},{"location":"25_config_features.html#format-priorities","text":"FILE_FORMAT_READING_PRIORITIES ( List<String> , default: DHALL,TOML,YAML,JSON5,JSON,ASN1,properties,INI ): Read order. FILE_FORMAT_WRITING_PRIORITIES ( List<String> , default: TOML,YAML,JSON5,JSON,properties ): Write order. FILE_FORMAT_READING_ALLOW_ALL_FORMATS (Boolean, default: true): Fallback to non-listed formats. FILE_FORMAT_WRITING_ALLOW_ALL_FORMATS (Boolean, default: true): Fallback to non-listed formats.","title":"Format priorities"},{"location":"25_config_features.html#storage-type-priorities","text":"STORAGE_TYPE_PRIORITIES ( List<String> , default: RAM,secrets,files,registry,registryjni,zookeeper,JAR ): Init/search order within a scope. STORAGE_TYPE_ALLOW_ALL_STORAGES (Boolean, default: true): Allow storages not explicitly listed.","title":"Storage type priorities"},{"location":"25_config_features.html#schemes-and-defaults","text":"CONFIG_SCHEME_LIST ( Map<String,ConfigScheme> ): Provide schemes programmatically. SCHEME_STRICT_MODE (Boolean, default: false): Reject keys not in the scheme. SCHEME_RESETS_DEFAULTS (Boolean, default: false): Replace existing defaults instead of merging. FREE_CONFIGURATION (Boolean): Allow configs without a scheme (behavior may evolve).","title":"Schemes and defaults"},{"location":"25_config_features.html#missing-entry-behavior","text":"EXCEPTION_ON_MISSING_ENTRY (Boolean, default: true): Throw when a key is absent. DEFAULT_ON_MISSING_ENTRY (Boolean, default: false): Return scheme defaults if missing (requires exceptions disabled). EXCEPTION_WHEN_CONFIGURATION_NOT_FOUND (Boolean, default: false): Throw if a configuration name is not found at all. FALLBACKS_ACROSS_SCOPES (Boolean, default: true): Allow fallback to less specific scopes on reads. WRITE_FALLBACK_ACROSS_SCOPES (Boolean, default: false): Allow fallback to more specific scopes on writes.","title":"Missing entry behavior"},{"location":"25_config_features.html#cache-and-update-checks","text":"UPDATE_CHECK_FREQUENCY_MS (Integer, default: 2000): Polling interval for cached sources. UPDATE_CHECK_SCOPES ( List<String> , default: all scopes): Limit update checks by scope. CACHE_CONFIGS (Boolean): Cache configurations in memory (experimental). AUTOMATIC_CONFIG_LOADING (Boolean): Auto-load configs before first read (experimental). AUTOMATIC_CONFIG_CREATION (Boolean): Auto-create configs on write (experimental). WRITE_SYNC (Boolean): Sync writes immediately (storage-dependent). NO_DEFAULT_DIRECTORIES (Boolean): Disable default filesystem paths (experimental).","title":"Cache and update checks"},{"location":"25_config_features.html#modules-and-runtime-configuration","text":"ALLOW_MCONFIG_RUNTIME_SETTINGS (Boolean, default: false): Allow MCONFIG_RUNTIME_* env overrides. ENABLE_SELF_CONFIGURATION (Boolean, default: true): Allow classpath self-configuration. ADDITIONAL_MODULE_PATHS ( List<String> ): Add module IDs/paths during discovery. DISABLED_MODULE_IDS ( List<String> ): Disable specific module IDs.","title":"Modules and runtime configuration"},{"location":"25_config_features.html#secrets-providers-mconfigsecrets","text":"SECRETS_PROVIDER_ID (String): Primary provider ID. SECRETS_PROVIDER_CONFIG ( Map<String,Object> ): Provider configuration. ADDITIONAL_SECRETS_PROVIDERS ( List<Map<String,Object>> ): Additional providers with optional scope.","title":"Secrets providers (mConfigSecrets)"},{"location":"25_config_features.html#zookeeper-mconfigsourcezookeeper","text":"ZOOKEEPER_CONNECT_STRING (String): Connection string. ZOOKEEPER_ROOT_PATH (String, default: /mconfig ): Root path. ZOOKEEPER_SESSION_TIMEOUT_MS (Integer, default: 60000): Session timeout. ZOOKEEPER_RETRY_BASE_SLEEP_MS (Integer, default: 1000): Retry base sleep. ZOOKEEPER_RETRY_MAX_RETRIES (Integer, default: 3): Retry count. ZOOKEEPER_BOOTSTRAP_CONFIG_NAME (String, default: zookeeper ): Bootstrap config name.","title":"ZooKeeper (mConfigSourceZooKeeper)"},{"location":"25_config_features.html#class-loading","text":"USE_CONTEXT_CLASS_LOADER (Boolean, default: false): Prefer thread context loader. USE_SYSTEM_CLASS_LOADER (Boolean, default: false): Prefer system class loader.","title":"Class loading"},{"location":"25_config_features.html#identity-and-context","text":"COMPANY_NAME (String, optional): Company/organization name used in OS paths. Blank/null/whitespace intentionally omits the company segment across all sources. APPLICATION_NAME (String, required): Application name used in OS paths. SUB_PATH (String, optional): Sub-path appended to application paths (e.g. \"profile/tenantA\" ). CURRENT_USER_ID (String, default: OS user): User ID for the current process. CURRENT_PLATFORM_OS (OperatingSystem, auto-detected): Detected OS family. HOSTNAME (String, auto-detected): Hostname of the current machine/container. These are automatically set by the library; they are available as a ConfigFeature so you can override them if needed.","title":"Identity and context"},{"location":"25_config_features.html#patterns-to-avoid-boilerplate","text":"Missing values: prefer EXCEPTION_ON_MISSING_ENTRY=false and DEFAULT_ON_MISSING_ENTRY=true over manual try/catch or null wrapping. Strict config contracts: set SCHEME_STRICT_MODE=true instead of filtering keys by hand. Default overrides: use SCHEME_RESETS_DEFAULTS or STORAGE_TYPE_PRIORITIES rather than manual \"merge\" code. Scope behavior: use FALLBACKS_ACROSS_SCOPES and WRITE_FALLBACK_ACROSS_SCOPES instead of explicit scope iteration.","title":"Patterns to avoid boilerplate"},{"location":"31_writing_configurations.html","text":"3.1 Writing Configurations \u00b6 Most of the time, we just read configs from software. After all, they are how software gets told where to find things and how to behave. But if you want to make things more comfortable, you'd also want to write configs. One main difference from reading is that it is less automatic; it can't be. When writing a config, you must specify the Scope. Otherwise, we'd have the writes all over the place, users overwriting each other's settings, and so on. So, you specify which Scope you are about to write. 3.1.1 Writing Priorities \u00b6 mConfig follows the \"principle of least surprise\" when writing to a scope: 1. Priority 1 : If an entry for the key already exists in a writeable layer within the scope, that entry is updated. 2. Priority 2 : If the key is new, it is added to the highest-priority writeable layer already available in the scope. 3. Priority 3 : Only if no writeable layers exist is a new configuration file/storage created. What's half-automatic is the format and location. We can use the hierarchy used for reading in writing as well, and we have a default format preference list. But for your specific project, conventions may be different. 3.1.2 Format caveats when writing \u00b6 Some formats allow extraneous information to be added manually, which is invisible from code. e.g. Java Properties allow comments, but its .load() function omits all of them. So if you do a load() followed by a store(), the comments will be gone in the stored version. You may want to think about this aspect when designing your application. mConfig helps you in this regard with layers and Scopes. 3.1.3 Type Preservation (Planned) \u00b6 Current : String-first impl ( String.valueOf(value) ) for simplicity. Planned : Pass typed objects to formats (e.g., unquoted numbers/booleans in JSON/YAML). See devdocs/type_preservation_plan.md . 3.1.4 Write Cache (Planned) \u00b6 For batch writes, enable cache via future ENABLE_CONFIG_CACHE feature, then flush() to persist. flush() will write cache and invalidate read cache.","title":"3.1 Writing Configurations"},{"location":"31_writing_configurations.html#31-writing-configurations","text":"Most of the time, we just read configs from software. After all, they are how software gets told where to find things and how to behave. But if you want to make things more comfortable, you'd also want to write configs. One main difference from reading is that it is less automatic; it can't be. When writing a config, you must specify the Scope. Otherwise, we'd have the writes all over the place, users overwriting each other's settings, and so on. So, you specify which Scope you are about to write.","title":"3.1 Writing Configurations"},{"location":"31_writing_configurations.html#311-writing-priorities","text":"mConfig follows the \"principle of least surprise\" when writing to a scope: 1. Priority 1 : If an entry for the key already exists in a writeable layer within the scope, that entry is updated. 2. Priority 2 : If the key is new, it is added to the highest-priority writeable layer already available in the scope. 3. Priority 3 : Only if no writeable layers exist is a new configuration file/storage created. What's half-automatic is the format and location. We can use the hierarchy used for reading in writing as well, and we have a default format preference list. But for your specific project, conventions may be different.","title":"3.1.1 Writing Priorities"},{"location":"31_writing_configurations.html#312-format-caveats-when-writing","text":"Some formats allow extraneous information to be added manually, which is invisible from code. e.g. Java Properties allow comments, but its .load() function omits all of them. So if you do a load() followed by a store(), the comments will be gone in the stored version. You may want to think about this aspect when designing your application. mConfig helps you in this regard with layers and Scopes.","title":"3.1.2 Format caveats when writing"},{"location":"31_writing_configurations.html#313-type-preservation-planned","text":"Current : String-first impl ( String.valueOf(value) ) for simplicity. Planned : Pass typed objects to formats (e.g., unquoted numbers/booleans in JSON/YAML). See devdocs/type_preservation_plan.md .","title":"3.1.3 Type Preservation (Planned)"},{"location":"31_writing_configurations.html#314-write-cache-planned","text":"For batch writes, enable cache via future ENABLE_CONFIG_CACHE feature, then flush() to persist. flush() will write cache and invalidate read cache.","title":"3.1.4 Write Cache (Planned)"},{"location":"32_updates.html","text":"3.2 Updates \u00b6 mConfig automatically detects and uses updates in the configuration sources. Thus, if you access Configuration contents, you'll receive the current values. Conversely, if you store the values you got from the mConfig Configuration in a local variable, that variable won't receive updates, of course. Now for the details. 3.2.1 Update notifications \u00b6 While the easiest way to use mConfig is just to get() from the Configuration whenever you need a value - there are library objects created using the values values, where you can't pass an mConfig handle. You would need to reinstantiate these, or do similar things. For this purpose, you can subscribe to changes, providing a callback which will get executed when a change occurs. 3.2.1.1 Location-level updates \u00b6 Configuration . subscribeToUpdates ( Consumer < ConfigLocation > listener ) Configuration . unsubscribeFromUpdates ( Consumer < ConfigLocation > listener ) The callback will be executed when any of the Configuration layers in the specified scopes gets changed content. Note on initial discovery: For subscribers, the transition from a non-existent entry to its first assigned value is treated as a change event. This ensures that dynamic entry creation is captured correctly. By default, the scopes exclude RUNTIME, because that's what you set yourself at runtime. The callback is provided as parameter with the ConfigLocation where the change occurred. (You can get the scope from it, e.g.) 3.2.1.2 Entry-level updates \u00b6 Configuration . subscribeToUpdates ( String fullKey , Consumer < ConfigLocation > listener ) Subscribe to changes of individual entries by their full key. The callback is called with the ConfigLocation where the entry change was detected. Unsubscribe with Configuration.unsubscribeFromUpdates(Consumer<ConfigLocation> listener) when you don't need it anymore; this feature requires a bit of CPU time when active. 3.2.2 Update settings \u00b6 To reduce overhead, mConfig limits the checks for new content to every x seconds. You can set this with the parameter XXXXXXXXXXXXTOBENAMED. NOT IMPLEMENTED YET: If you set this parameter to 0, mConfig is instructed to perform checks on all its potential sources on each variable access. If you really need this amount of overhead... please give notice, explain the use case, and we'll get it done.","title":"3.2 Updates"},{"location":"32_updates.html#32-updates","text":"mConfig automatically detects and uses updates in the configuration sources. Thus, if you access Configuration contents, you'll receive the current values. Conversely, if you store the values you got from the mConfig Configuration in a local variable, that variable won't receive updates, of course. Now for the details.","title":"3.2 Updates"},{"location":"32_updates.html#321-update-notifications","text":"While the easiest way to use mConfig is just to get() from the Configuration whenever you need a value - there are library objects created using the values values, where you can't pass an mConfig handle. You would need to reinstantiate these, or do similar things. For this purpose, you can subscribe to changes, providing a callback which will get executed when a change occurs.","title":"3.2.1 Update notifications"},{"location":"32_updates.html#3211-location-level-updates","text":"Configuration . subscribeToUpdates ( Consumer < ConfigLocation > listener ) Configuration . unsubscribeFromUpdates ( Consumer < ConfigLocation > listener ) The callback will be executed when any of the Configuration layers in the specified scopes gets changed content. Note on initial discovery: For subscribers, the transition from a non-existent entry to its first assigned value is treated as a change event. This ensures that dynamic entry creation is captured correctly. By default, the scopes exclude RUNTIME, because that's what you set yourself at runtime. The callback is provided as parameter with the ConfigLocation where the change occurred. (You can get the scope from it, e.g.)","title":"3.2.1.1 Location-level updates"},{"location":"32_updates.html#3212-entry-level-updates","text":"Configuration . subscribeToUpdates ( String fullKey , Consumer < ConfigLocation > listener ) Subscribe to changes of individual entries by their full key. The callback is called with the ConfigLocation where the entry change was detected. Unsubscribe with Configuration.unsubscribeFromUpdates(Consumer<ConfigLocation> listener) when you don't need it anymore; this feature requires a bit of CPU time when active.","title":"3.2.1.2 Entry-level updates"},{"location":"32_updates.html#322-update-settings","text":"To reduce overhead, mConfig limits the checks for new content to every x seconds. You can set this with the parameter XXXXXXXXXXXXTOBENAMED. NOT IMPLEMENTED YET: If you set this parameter to 0, mConfig is instructed to perform checks on all its potential sources on each variable access. If you really need this amount of overhead... please give notice, explain the use case, and we'll get it done.","title":"3.2.2 Update settings"},{"location":"33_getting_information.html","text":"3.3 Getting Information \u00b6 3.3.1 Locations \u00b6 So, where is my specific configuration looking for its contents? To see where a Configuration instance gets its contents from, you can use getSourceLocations() like this: System . out . println ( \"config locations: \" ); for ( ConfigLocation location : cfg . getSourceLocations ()) System . out . println ( \"\\t\" + location . getScope () + \"\\t\" + location . getURI ( \"entry\" , null )); And where is the overall mConfig factory instance looking, in general? There is getSearchList() from ConfigFactory. System . out . println ( \"searchList: \" ); for ( ConfigLocation location : searchList ) System . out . println ( \"\\t\" + location . getScope () + \"\\t\" + location . getURI ( \"entry\" , null )); Depending on your use case, you'll want different parts of the ConfigLocation entries. Above is just a little text dump. 3.3.2 Legacy support: BLOBs, and where to put files? \u00b6 Use Configuration mechanisms where possible; this enables all the features, including scheme checking, network storage, and so on. 3.3.2.1 Raw Files (Text and Binary) \u00b6 You may need to access the entire content of a file as a single String or byte array. mConfig provides two specialized formats for this purpose: text_file and binary_file . Reading a text file as a single String: By using the text_file format, the entire file content is read into a single entry with an empty key \"\" . try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"text_file\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"myTextFile\" ); String content = cfg . getString ( \"\" ); } Reading a binary file as a byte array: The binary_file format works similarly but provides the content as a byte array. try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"binary_file\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"myBinaryFile\" ); byte [] content = cfg . getBytes ( \"\" ); } 3.3.2.2 Hierarchical BLOBs \u00b6 In modern formats like JSON and YAML, binary data can be part of the hierarchical structure. JSON (Base64): If a ConfigScheme defines a key as type BYTES , mConfig will automatically decode a Base64-encoded string in a JSON file. YAML (!!binary): YAML supports binary data natively using the !!binary tag. mConfig will correctly retrieve these as byte arrays. byte [] data = cfg . getBytes ( \"server/certificate\" ); 3.3.2.3 Legacy BLOBs \u00b6 The second fallback for supporting legacy applications is that you can get filesystem paths for a given Scope. If there are several for the same Scope, mConfigUtil will prioritize the most specific entry, and prefer those which exist already over those which would need to be created. Path localPath = ConfigUtil . whereToPutMyFiles ( configFactory , ConfigScope . USER , false ); But please, consider using regular mConfig functionality instead where possible.","title":"3.3 Getting Information"},{"location":"33_getting_information.html#33-getting-information","text":"","title":"3.3 Getting Information"},{"location":"33_getting_information.html#331-locations","text":"So, where is my specific configuration looking for its contents? To see where a Configuration instance gets its contents from, you can use getSourceLocations() like this: System . out . println ( \"config locations: \" ); for ( ConfigLocation location : cfg . getSourceLocations ()) System . out . println ( \"\\t\" + location . getScope () + \"\\t\" + location . getURI ( \"entry\" , null )); And where is the overall mConfig factory instance looking, in general? There is getSearchList() from ConfigFactory. System . out . println ( \"searchList: \" ); for ( ConfigLocation location : searchList ) System . out . println ( \"\\t\" + location . getScope () + \"\\t\" + location . getURI ( \"entry\" , null )); Depending on your use case, you'll want different parts of the ConfigLocation entries. Above is just a little text dump.","title":"3.3.1 Locations"},{"location":"33_getting_information.html#332-legacy-support-blobs-and-where-to-put-files","text":"Use Configuration mechanisms where possible; this enables all the features, including scheme checking, network storage, and so on.","title":"3.3.2 Legacy support: BLOBs, and where to put files?"},{"location":"33_getting_information.html#3321-raw-files-text-and-binary","text":"You may need to access the entire content of a file as a single String or byte array. mConfig provides two specialized formats for this purpose: text_file and binary_file . Reading a text file as a single String: By using the text_file format, the entire file content is read into a single entry with an empty key \"\" . try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"text_file\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"myTextFile\" ); String content = cfg . getString ( \"\" ); } Reading a binary file as a byte array: The binary_file format works similarly but provides the content as a byte array. try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"binary_file\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"myBinaryFile\" ); byte [] content = cfg . getBytes ( \"\" ); }","title":"3.3.2.1 Raw Files (Text and Binary)"},{"location":"33_getting_information.html#3322-hierarchical-blobs","text":"In modern formats like JSON and YAML, binary data can be part of the hierarchical structure. JSON (Base64): If a ConfigScheme defines a key as type BYTES , mConfig will automatically decode a Base64-encoded string in a JSON file. YAML (!!binary): YAML supports binary data natively using the !!binary tag. mConfig will correctly retrieve these as byte arrays. byte [] data = cfg . getBytes ( \"server/certificate\" );","title":"3.3.2.2 Hierarchical BLOBs"},{"location":"33_getting_information.html#3323-legacy-blobs","text":"The second fallback for supporting legacy applications is that you can get filesystem paths for a given Scope. If there are several for the same Scope, mConfigUtil will prioritize the most specific entry, and prefer those which exist already over those which would need to be created. Path localPath = ConfigUtil . whereToPutMyFiles ( configFactory , ConfigScope . USER , false ); But please, consider using regular mConfig functionality instead where possible.","title":"3.3.2.3 Legacy BLOBs"},{"location":"34_definitions_and_valid_values.html","text":"3.4 Definitions and valid values \u00b6 3.4.1 Configuration names \u00b6 Configuration names identify which configuration to access. This needs to be portable across different storage backends and platforms (files, environment variables, JAR resources, etc.). These rules aim to minimize surprises and increase security. null is not allowed and will result in an error. The empty string \"\" is technically allowed, but reserved for internal aggregation use cases. Avoid using \"\" in normal application code. Whitespace handling Leading and trailing whitespace are actively omitted. Multiple internal whitespace characters collapse to a single space. on some backends, whitespace is replaced by underscores. Allowed characters (portable set) Letters A\u2013Z, a\u2013z Digits 0\u20139 Dot . Underscore _ Hyphen - Space In regex form: [A-Za-z0-9._- ] (spaces are allowed) Some sources (e.g. Filesystem) may sanitize dot usage to guard against path traversal attacks. Configuration names are case sensitive. Examples Valid: \"testconfig\", \"my.config\", \"my_config\", \"my-config\", \"My Config\", \"prod.v2\" invalid: \"my/config\", \"my:config\", \"my*config\", \"conf|g\", \"config<>\", \"config\\tname\"","title":"3.4 Definitions and Valid Values"},{"location":"34_definitions_and_valid_values.html#34-definitions-and-valid-values","text":"","title":"3.4 Definitions and valid values"},{"location":"34_definitions_and_valid_values.html#341-configuration-names","text":"Configuration names identify which configuration to access. This needs to be portable across different storage backends and platforms (files, environment variables, JAR resources, etc.). These rules aim to minimize surprises and increase security. null is not allowed and will result in an error. The empty string \"\" is technically allowed, but reserved for internal aggregation use cases. Avoid using \"\" in normal application code. Whitespace handling Leading and trailing whitespace are actively omitted. Multiple internal whitespace characters collapse to a single space. on some backends, whitespace is replaced by underscores. Allowed characters (portable set) Letters A\u2013Z, a\u2013z Digits 0\u20139 Dot . Underscore _ Hyphen - Space In regex form: [A-Za-z0-9._- ] (spaces are allowed) Some sources (e.g. Filesystem) may sanitize dot usage to guard against path traversal attacks. Configuration names are case sensitive. Examples Valid: \"testconfig\", \"my.config\", \"my_config\", \"my-config\", \"My Config\", \"prod.v2\" invalid: \"my/config\", \"my:config\", \"my*config\", \"conf|g\", \"config<>\", \"config\\tname\"","title":"3.4.1 Configuration names"},{"location":"35_handling_secrets.html","text":"3.5 Handling Secrets \u00b6 mConfig provides a secure way to handle sensitive information like passwords and keys. 3.5.1 Retrieving Secrets \u00b6 The getSecret(key) method returns a SecretValue object, which provides safe access to the sensitive data. SecretValue dbPassword = cfg . getSecret ( \"database/password\" ); if ( dbPassword != null ) { char [] passwordChars = dbPassword . getChars (); // Use passwordChars ... // Note: SecretValue.erase() can be used to clear internal buffers dbPassword . erase (); } 3.5.2 Scheme Integration \u00b6 To ensure an entry is treated as a secret, you must mark it with the SECRET flag in your ConfigScheme . { \"database/password\" : { \"type\" : \"STRING\" , \"flags\" : [ \"SECRET\" ], \"description\" : \"Database connection password\" } } When an entry is marked as a secret: - It is automatically redacted in logs and toString() calls. - It is stored in a specialized SecretConfigEntryLeaf that avoids converting the value to a standard String where possible. 3.5.3 Binary Secrets and Crypto Libraries \u00b6 mConfig seamlessly integrates with JCE and other crypto libraries. You can store raw key bytes as BYTES entries and retrieve them as SecretValue . // Retrieving a private key SecretValue privKeySecret = cfg . getSecret ( \"server/privateKey\" ); byte [] keyBytes = privKeySecret . getValue (); // Reconstruct the key using JCE KeyFactory kf = KeyFactory . getInstance ( \"RSA\" ); PrivateKey privKey = kf . generatePrivate ( new PKCS8EncodedKeySpec ( keyBytes ));","title":"3.5 Handling Secrets"},{"location":"35_handling_secrets.html#35-handling-secrets","text":"mConfig provides a secure way to handle sensitive information like passwords and keys.","title":"3.5 Handling Secrets"},{"location":"35_handling_secrets.html#351-retrieving-secrets","text":"The getSecret(key) method returns a SecretValue object, which provides safe access to the sensitive data. SecretValue dbPassword = cfg . getSecret ( \"database/password\" ); if ( dbPassword != null ) { char [] passwordChars = dbPassword . getChars (); // Use passwordChars ... // Note: SecretValue.erase() can be used to clear internal buffers dbPassword . erase (); }","title":"3.5.1 Retrieving Secrets"},{"location":"35_handling_secrets.html#352-scheme-integration","text":"To ensure an entry is treated as a secret, you must mark it with the SECRET flag in your ConfigScheme . { \"database/password\" : { \"type\" : \"STRING\" , \"flags\" : [ \"SECRET\" ], \"description\" : \"Database connection password\" } } When an entry is marked as a secret: - It is automatically redacted in logs and toString() calls. - It is stored in a specialized SecretConfigEntryLeaf that avoids converting the value to a standard String where possible.","title":"3.5.2 Scheme Integration"},{"location":"35_handling_secrets.html#353-binary-secrets-and-crypto-libraries","text":"mConfig seamlessly integrates with JCE and other crypto libraries. You can store raw key bytes as BYTES entries and retrieve them as SecretValue . // Retrieving a private key SecretValue privKeySecret = cfg . getSecret ( \"server/privateKey\" ); byte [] keyBytes = privKeySecret . getValue (); // Reconstruct the key using JCE KeyFactory kf = KeyFactory . getInstance ( \"RSA\" ); PrivateKey privKey = kf . generatePrivate ( new PKCS8EncodedKeySpec ( keyBytes ));","title":"3.5.3 Binary Secrets and Crypto Libraries"},{"location":"36_windows_registry.html","text":"3.6 Windows Registry Access \u00b6 mConfig provides two alternative modules for accessing the Windows Registry. Both support reading configuration data from HKEY_CURRENT_USER (USER scope), HKEY_LOCAL_MACHINE (MACHINE scope), and Group Policy Objects (GPO) in both hives (POLICY scope). 3.6.1 Choosing the Right Module \u00b6 Feature mConfigWinRegistry mConfigWinRegistryJNI Technology JNR-FFI (Dynamic Native) JNI (Java Native Interface) Artifact Size ~13 KB ~47 KB (includes DLL) Runtime Size ~1.5 MB (includes dependencies) ~47 KB Dependencies JNR-FFI, ASM, JFFI None Complexity Zero (no DLL to manage) Medium (DLL handling) Build Req. Standard Java/Maven Linux + MinGW-w64 (for DLL) Performance High Very High mConfigWinRegistry (JNR-FFI based) \u00b6 This module is the easiest to use as it requires no native toolchain and handles native access dynamically. - Pros : No native binaries to manage; works out-of-the-box. - Cons : Significantly larger footprint (~1.5 MB) due to the JNR-FFI ecosystem. - Requirement : Java 11+. mConfigWinRegistryJNI (JNI based) \u00b6 This module provides the smallest footprint and highest performance by using a custom-built DLL. - Pros : Extremely lightweight; no external dependencies. - Cons : Requires building a DLL on Linux (cross-compiled for Windows); the DLL must be provided to the end-user (usually bundled in the JAR). - Requirement : Windows DLL ( mConfigWinRegistryJNI.dll ). - Signing : The bundled DLL is provided unsigned . For production deployments, application developers are responsible for signing the DLL as part of their distribution to establish a \"Chain of Trust\". 3.6.2 Priority and Discovery \u00b6 If both modules are present on the classpath, mConfig defaults to using mConfigWinRegistryJNI ( registryjni ) over mConfigWinRegistry ( registry ) for better performance. To use a specific one, you can configure STORAGE_TYPE_PRIORITIES : try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"registryjni\" )) // Force JNI . build ()) { // ... } 3.6.3 Base Path Configuration \u00b6 By default, the registry source looks under Software\\\\[<CompanyName>\\\\\\\\]<ApplicationName> (company segment omitted if COMPANY_NAME blank/null/whitespace). You can override this using the REGISTRY_BASE_PATH feature: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . REGISTRY_BASE_PATH , \"Software\\\\LegacyPath\\\\App\" ) . build ()) { // ... }","title":"3.6 Windows Registry Access"},{"location":"36_windows_registry.html#36-windows-registry-access","text":"mConfig provides two alternative modules for accessing the Windows Registry. Both support reading configuration data from HKEY_CURRENT_USER (USER scope), HKEY_LOCAL_MACHINE (MACHINE scope), and Group Policy Objects (GPO) in both hives (POLICY scope).","title":"3.6 Windows Registry Access"},{"location":"36_windows_registry.html#361-choosing-the-right-module","text":"Feature mConfigWinRegistry mConfigWinRegistryJNI Technology JNR-FFI (Dynamic Native) JNI (Java Native Interface) Artifact Size ~13 KB ~47 KB (includes DLL) Runtime Size ~1.5 MB (includes dependencies) ~47 KB Dependencies JNR-FFI, ASM, JFFI None Complexity Zero (no DLL to manage) Medium (DLL handling) Build Req. Standard Java/Maven Linux + MinGW-w64 (for DLL) Performance High Very High","title":"3.6.1 Choosing the Right Module"},{"location":"36_windows_registry.html#mconfigwinregistry-jnr-ffi-based","text":"This module is the easiest to use as it requires no native toolchain and handles native access dynamically. - Pros : No native binaries to manage; works out-of-the-box. - Cons : Significantly larger footprint (~1.5 MB) due to the JNR-FFI ecosystem. - Requirement : Java 11+.","title":"mConfigWinRegistry (JNR-FFI based)"},{"location":"36_windows_registry.html#mconfigwinregistryjni-jni-based","text":"This module provides the smallest footprint and highest performance by using a custom-built DLL. - Pros : Extremely lightweight; no external dependencies. - Cons : Requires building a DLL on Linux (cross-compiled for Windows); the DLL must be provided to the end-user (usually bundled in the JAR). - Requirement : Windows DLL ( mConfigWinRegistryJNI.dll ). - Signing : The bundled DLL is provided unsigned . For production deployments, application developers are responsible for signing the DLL as part of their distribution to establish a \"Chain of Trust\".","title":"mConfigWinRegistryJNI (JNI based)"},{"location":"36_windows_registry.html#362-priority-and-discovery","text":"If both modules are present on the classpath, mConfig defaults to using mConfigWinRegistryJNI ( registryjni ) over mConfigWinRegistry ( registry ) for better performance. To use a specific one, you can configure STORAGE_TYPE_PRIORITIES : try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"registryjni\" )) // Force JNI . build ()) { // ... }","title":"3.6.2 Priority and Discovery"},{"location":"36_windows_registry.html#363-base-path-configuration","text":"By default, the registry source looks under Software\\\\[<CompanyName>\\\\\\\\]<ApplicationName> (company segment omitted if COMPANY_NAME blank/null/whitespace). You can override this using the REGISTRY_BASE_PATH feature: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . REGISTRY_BASE_PATH , \"Software\\\\LegacyPath\\\\App\" ) . build ()) { // ... }","title":"3.6.3 Base Path Configuration"},{"location":"37_extensions_and_advanced_use.html","text":"3.7 Extensions and Advanced Use \u00b6 3.7.1 Using extensions \u00b6 3.7.2 Advanced use \u00b6 Why perform parameter validation, checks for presence of mandatory settings, generation of parameter documentation yourself? mConfig has a built-in facility for this and more. You describe all the entries your configuration can have, and mConfig takes care of the checking. 3.7.3 Data types \u00b6 3.7.3.1 Config scheme formats \u00b6 3.7.3.1.1 Internal format 0: single ConfigSchemeEntry \u00b6 { \"key\":\"mandatory key / configuration entry name\", \"TYPE\":\"mandatory type\", \"DEFAULT\":\"optional default value, as string\", \"DESCRIPTION\":\"optional description, for the documentation\", \"DESCRIPTION\":{\"en\":\"English description\", \"de\":\"Deutsche Beschreibung\"}, \"PATTERN\":\"optional validation pattern\", \"SCOPES\":[ \"optional\", \"scopes\", \"this\", \"is\", \"valid\", \"in\"], \"FLAGS\":[\"flags\"], \"SECRET\":false, \"HIDDEN\":false } Multi-language descriptions are supported by providing a map of language codes to description texts. When requested via getDescription(Locale) , the library will first check this map, then fall back to standard ResourceBundle lookup (using .config/messages.properties ), and finally fall back to the single string description if provided. PLAN : For FLAGS, in the future we may chose an alternative form - each being a pair with string key and boolean value. 3.7.3.1.2 Internal format 1: ConfigSchemes, in an array. internal use only! \u00b6 [ SCHEME_ENTRIES, GO_HERE, DEFINED_AS_IN_FORMAT_1 ] 3.7.3.1.3 Format 2: full single ConfigScheme \u00b6 { \"name\":\"mandatory name the Configuration is identified by\", \"entries\":[ ENTRIES_AS_DEFINED_IN_FORMAT_2 ], } 3.7.3.1.4 Format 3: multiple full ConfigSchemes \u00b6 [ FULL_CONFIG_SCHEME_AS_DEFINED_IN_FORMAT_3 ] stateDiagram-v2 direction LR [*] --> UNDECIDED UNDECIDED --> ARRAY : on [ UNDECIDED --> SCHEME: on { SCHEME --> SCHEME_ENDED : on } SCHEME --> ENTRY_KEY: on string ENTRY --> SCHEME: on next value 3.7.4 configure priorities \u00b6 3.7.4.1 File Type Priority \u00b6 You can control the resolution priority between different file types (e.g., JSON, YAML) using the FILE_TYPE_PRIORITIES feature. This re-orders the search list within each scope. 3.7.4.2 Storage Type Priority \u00b6 You can control the resolution priority between different storage types (e.g., Files vs. Registry) using the STORAGE_TYPE_PRIORITIES feature. This re-orders the search list within each scope. ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"registry\" , \"registryjni\" , \"JAR\" )); try ( ConfigFactory factory = builder . build ()) { // ... } Default IDs include: RAM , secrets , files , registry , registryjni , JAR . Additional directories provided via features like ADDITIONAL_USER_DIRECTORIES are typically prepended to the search list for their scope. This makes them the preferred location for creating new configuration files, while still allowing default files in standard locations to provide values (unless the same key is defined in the additional directory).","title":"3.7 Extensions and Advanced Use"},{"location":"37_extensions_and_advanced_use.html#37-extensions-and-advanced-use","text":"","title":"3.7 Extensions and Advanced Use"},{"location":"37_extensions_and_advanced_use.html#371-using-extensions","text":"","title":"3.7.1 Using extensions"},{"location":"37_extensions_and_advanced_use.html#372-advanced-use","text":"Why perform parameter validation, checks for presence of mandatory settings, generation of parameter documentation yourself? mConfig has a built-in facility for this and more. You describe all the entries your configuration can have, and mConfig takes care of the checking.","title":"3.7.2 Advanced use"},{"location":"37_extensions_and_advanced_use.html#373-data-types","text":"","title":"3.7.3 Data types"},{"location":"37_extensions_and_advanced_use.html#3731-config-scheme-formats","text":"","title":"3.7.3.1 Config scheme formats"},{"location":"37_extensions_and_advanced_use.html#37311-internal-format-0-single-configschemeentry","text":"{ \"key\":\"mandatory key / configuration entry name\", \"TYPE\":\"mandatory type\", \"DEFAULT\":\"optional default value, as string\", \"DESCRIPTION\":\"optional description, for the documentation\", \"DESCRIPTION\":{\"en\":\"English description\", \"de\":\"Deutsche Beschreibung\"}, \"PATTERN\":\"optional validation pattern\", \"SCOPES\":[ \"optional\", \"scopes\", \"this\", \"is\", \"valid\", \"in\"], \"FLAGS\":[\"flags\"], \"SECRET\":false, \"HIDDEN\":false } Multi-language descriptions are supported by providing a map of language codes to description texts. When requested via getDescription(Locale) , the library will first check this map, then fall back to standard ResourceBundle lookup (using .config/messages.properties ), and finally fall back to the single string description if provided. PLAN : For FLAGS, in the future we may chose an alternative form - each being a pair with string key and boolean value.","title":"3.7.3.1.1 Internal format 0: single ConfigSchemeEntry"},{"location":"37_extensions_and_advanced_use.html#37312-internal-format-1-configschemes-in-an-array-internal-use-only","text":"[ SCHEME_ENTRIES, GO_HERE, DEFINED_AS_IN_FORMAT_1 ]","title":"3.7.3.1.2 Internal format 1:  ConfigSchemes, in an array. internal use only!"},{"location":"37_extensions_and_advanced_use.html#37313-format-2-full-single-configscheme","text":"{ \"name\":\"mandatory name the Configuration is identified by\", \"entries\":[ ENTRIES_AS_DEFINED_IN_FORMAT_2 ], }","title":"3.7.3.1.3 Format 2: full single ConfigScheme"},{"location":"37_extensions_and_advanced_use.html#37314-format-3-multiple-full-configschemes","text":"[ FULL_CONFIG_SCHEME_AS_DEFINED_IN_FORMAT_3 ] stateDiagram-v2 direction LR [*] --> UNDECIDED UNDECIDED --> ARRAY : on [ UNDECIDED --> SCHEME: on { SCHEME --> SCHEME_ENDED : on } SCHEME --> ENTRY_KEY: on string ENTRY --> SCHEME: on next value","title":"3.7.3.1.4 Format 3: multiple full ConfigSchemes"},{"location":"37_extensions_and_advanced_use.html#374-configure-priorities","text":"","title":"3.7.4 configure priorities"},{"location":"37_extensions_and_advanced_use.html#3741-file-type-priority","text":"You can control the resolution priority between different file types (e.g., JSON, YAML) using the FILE_TYPE_PRIORITIES feature. This re-orders the search list within each scope.","title":"3.7.4.1 File Type Priority"},{"location":"37_extensions_and_advanced_use.html#3742-storage-type-priority","text":"You can control the resolution priority between different storage types (e.g., Files vs. Registry) using the STORAGE_TYPE_PRIORITIES feature. This re-orders the search list within each scope. ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"company\" , \"app\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"registry\" , \"registryjni\" , \"JAR\" )); try ( ConfigFactory factory = builder . build ()) { // ... } Default IDs include: RAM , secrets , files , registry , registryjni , JAR . Additional directories provided via features like ADDITIONAL_USER_DIRECTORIES are typically prepended to the search list for their scope. This makes them the preferred location for creating new configuration files, while still allowing default files in standard locations to provide values (unless the same key is defined in the additional directory).","title":"3.7.4.2 Storage Type Priority"},{"location":"38_code_improvements.html","text":"3.8 Code Improvements and Best Practices \u00b6 Defaults \u00b6 Replace code like Properties defaults = new Properties (); ClassLoader classLoader = Thread . currentThread (). getContextClassLoader (); InputStream input = classLoader . getResourceAsStream ( \"defaultconfig.properties\" ); try { defaults . load ( input ); } catch ( IOException e ) { e . printStackTrace (); } with simply using mConfig. Its module mConfigSourceJAR automatically loads defaults from .config/CONFIGNAME.EXTENSIONS in the resource folder of your JAR - besides all its other locations. So, you can remove blocks like the above entirely. Common Pitfalls and Feature Flags \u00b6 Common mistakes when starting with mConfig, and the feature flags that help avoid them: Redundant Null Checks: By default, EXCEPTION_ON_MISSING_ENTRY is true , so getters throw ConfigException instead of returning null . This removes the need for if (value == null) value = \"placeholder\" boilerplate. Replace: String version = config . getString ( \"version\" ); if ( version == null ) { version = \"unknown\" ; } With: try { String version = config . getString ( \"version\" ); // use version } catch ( ConfigException e ) { // handle missing value once } Reminder: You can provide defaults in the resource folder of your JAR. Manual null handling for missing values: Alternatively, use EXCEPTION_ON_MISSING_ENTRY=false and DEFAULT_ON_MISSING_ENTRY=true to automatically return scheme defaults instead of null . Manual strictness checks: Set SCHEME_STRICT_MODE=true to reject unknown keys at runtime. Manual scope fallback loops: Control with FALLBACKS_ACROSS_SCOPES (for reads) and WRITE_FALLBACK_ACROSS_SCOPES (for writes). Custom format probing: Configure FILE_FORMAT_READING_PRIORITIES and FILE_FORMAT_WRITING_PRIORITIES declaratively instead of hardcoding. These features promote a declarative style, reducing boilerplate and errors.","title":"3.8 Code Improvements"},{"location":"38_code_improvements.html#38-code-improvements-and-best-practices","text":"","title":"3.8 Code Improvements and Best Practices"},{"location":"38_code_improvements.html#defaults","text":"Replace code like Properties defaults = new Properties (); ClassLoader classLoader = Thread . currentThread (). getContextClassLoader (); InputStream input = classLoader . getResourceAsStream ( \"defaultconfig.properties\" ); try { defaults . load ( input ); } catch ( IOException e ) { e . printStackTrace (); } with simply using mConfig. Its module mConfigSourceJAR automatically loads defaults from .config/CONFIGNAME.EXTENSIONS in the resource folder of your JAR - besides all its other locations. So, you can remove blocks like the above entirely.","title":"Defaults"},{"location":"38_code_improvements.html#common-pitfalls-and-feature-flags","text":"Common mistakes when starting with mConfig, and the feature flags that help avoid them: Redundant Null Checks: By default, EXCEPTION_ON_MISSING_ENTRY is true , so getters throw ConfigException instead of returning null . This removes the need for if (value == null) value = \"placeholder\" boilerplate. Replace: String version = config . getString ( \"version\" ); if ( version == null ) { version = \"unknown\" ; } With: try { String version = config . getString ( \"version\" ); // use version } catch ( ConfigException e ) { // handle missing value once } Reminder: You can provide defaults in the resource folder of your JAR. Manual null handling for missing values: Alternatively, use EXCEPTION_ON_MISSING_ENTRY=false and DEFAULT_ON_MISSING_ENTRY=true to automatically return scheme defaults instead of null . Manual strictness checks: Set SCHEME_STRICT_MODE=true to reject unknown keys at runtime. Manual scope fallback loops: Control with FALLBACKS_ACROSS_SCOPES (for reads) and WRITE_FALLBACK_ACROSS_SCOPES (for writes). Custom format probing: Configure FILE_FORMAT_READING_PRIORITIES and FILE_FORMAT_WRITING_PRIORITIES declaratively instead of hardcoding. These features promote a declarative style, reducing boilerplate and errors.","title":"Common Pitfalls and Feature Flags"},{"location":"41_mconfig_tool.html","text":"4.1 mConfig Tool ( mconfig ) \u00b6 The mconfig tool provides a command-line interface for inspecting and managing configurations. It allows you to list available configurations, show effective values, get detailed metadata for specific keys, search for configuration paths, and more. 4.1.1 Installation \u00b6 The tool is available as a \"fat JAR\" in the mConfigTools module. You can run it using: java -jar mConfigTools-*.jar [ OPTIONS ] [ COMMAND ] [ COMMAND_OPTIONS ] 4.1.2 Subcommands \u00b6 list : List all available configurations for the given company and application. show : Print the effective configuration (all keys and values). get : Show detailed information for a specific key (value, type, source URI, scope, and description). search-paths : List all directories and storage locations where mConfig looks for files. propose-scheme : Generate a draft ConfigScheme JSON from an existing configuration. validate : Validate a configuration against its scheme. set : Set or update a configuration entry. Requires --value and --scope . monitor : Monitor a configuration for real-time changes. Keeps running until interrupted. 4.1.2.1 set command options: \u00b6 -V, --value=<value> : The value to set. -S, --scope=<scope> : Target ConfigScope ( USER , HOST , SESSION , RUNTIME , etc.). -T, --type=<type> : ConfigEntryType (optional, inferred from scheme if available). -d, --dry-run : Display what would be changed without performing the actual write. 4.1.2.2 monitor command options: \u00b6 --dump : Print the full effective configuration before starting the monitor loop. -v, --verbose : Provide more detail about changes (e.g., the scope of the change). 4.1.3 Global Options and Commands \u00b6 Options can be placed both before and after the command (verb). -c, --company=<name> : Company name (default: MCONFIG_COMPANY env var). Use \"\" (empty string) intentionally to omit the company segment in all paths/sources (e.g., ~/.config/myapp/ ). -a, --app=<name> : Application name (default: MCONFIG_APP env var) -C, --config=<name> : Configuration name (default: MCONFIG_CONFIG env var) -k, --key=<name> : Specific configuration key -o, --output=<format> : Output format ( HUMAN , JSON , CSV ) -v, --verbose : Enable verbose output (shows source URIs and scopes) -l, --lang=<lang> : Preferred language for descriptions (default: en ) Do not underestimate the power of \"-v\" verbose mode! Try it and see which extra information you can get out of it. 4.1.4 Shortened Syntax \u00b6 For quick interactive use, the tool supports a positional argument in the format: [COMPANY:]APPLICATION[:CONFIGNAME[:KEY]] where COMPANY can be empty \"\" to omit the company segment in paths (use leading : e.g. :myapp:settings ). Examples: - mconfig mycompany:myapp:database show (with company) - mconfig :myapp:database show (app-only) Both equivalent to mconfig --company [\"\"\"\"] --app myapp --config database show . 4.1.5 Environment Variables \u00b6 The tool automatically picks up the following environment variables if the corresponding options are not provided: - MCONFIG_COMPANY - MCONFIG_APP - MCONFIG_CONFIG 4.1.6 Examples \u00b6 List configurations: mconfig --company mycomp --app myapp list Show effective configuration: mconfig mycomp:myapp:settings show # OR mconfig show --company mycomp --app myapp --config settings Get value and metadata for a specific key: mconfig mycomp:myapp:db:password get Change output to JSON for scripting: mconfig mycomp:myapp:settings show -o JSON See where the values in your configuration are coming from: mconfig mycomp:myapp:settings show -v Set a configuration value: mconfig mycomp:myapp:db:user set --value = \"dbuser\" --scope = USER Update a configuration value with dry-run and validation: mconfig mycomp:myapp:settings:timeout set -V 30 -S HOST -T NUMBER --dry-run Monitor configuration changes: This one's for you, SRE and developers! mconfig mycomp:myapp:settings monitor --dump -v mconfig :myapp:settings monitor --dump -v # app-only App-only examples (omit company segment): mconfig -c \"\" myapp list mconfig :myapp:db get password","title":"4.1 mConfig Tool"},{"location":"41_mconfig_tool.html#41-mconfig-tool-mconfig","text":"The mconfig tool provides a command-line interface for inspecting and managing configurations. It allows you to list available configurations, show effective values, get detailed metadata for specific keys, search for configuration paths, and more.","title":"4.1 mConfig Tool (mconfig)"},{"location":"41_mconfig_tool.html#411-installation","text":"The tool is available as a \"fat JAR\" in the mConfigTools module. You can run it using: java -jar mConfigTools-*.jar [ OPTIONS ] [ COMMAND ] [ COMMAND_OPTIONS ]","title":"4.1.1 Installation"},{"location":"41_mconfig_tool.html#412-subcommands","text":"list : List all available configurations for the given company and application. show : Print the effective configuration (all keys and values). get : Show detailed information for a specific key (value, type, source URI, scope, and description). search-paths : List all directories and storage locations where mConfig looks for files. propose-scheme : Generate a draft ConfigScheme JSON from an existing configuration. validate : Validate a configuration against its scheme. set : Set or update a configuration entry. Requires --value and --scope . monitor : Monitor a configuration for real-time changes. Keeps running until interrupted.","title":"4.1.2 Subcommands"},{"location":"41_mconfig_tool.html#4121-set-command-options","text":"-V, --value=<value> : The value to set. -S, --scope=<scope> : Target ConfigScope ( USER , HOST , SESSION , RUNTIME , etc.). -T, --type=<type> : ConfigEntryType (optional, inferred from scheme if available). -d, --dry-run : Display what would be changed without performing the actual write.","title":"4.1.2.1 set command options:"},{"location":"41_mconfig_tool.html#4122-monitor-command-options","text":"--dump : Print the full effective configuration before starting the monitor loop. -v, --verbose : Provide more detail about changes (e.g., the scope of the change).","title":"4.1.2.2 monitor command options:"},{"location":"41_mconfig_tool.html#413-global-options-and-commands","text":"Options can be placed both before and after the command (verb). -c, --company=<name> : Company name (default: MCONFIG_COMPANY env var). Use \"\" (empty string) intentionally to omit the company segment in all paths/sources (e.g., ~/.config/myapp/ ). -a, --app=<name> : Application name (default: MCONFIG_APP env var) -C, --config=<name> : Configuration name (default: MCONFIG_CONFIG env var) -k, --key=<name> : Specific configuration key -o, --output=<format> : Output format ( HUMAN , JSON , CSV ) -v, --verbose : Enable verbose output (shows source URIs and scopes) -l, --lang=<lang> : Preferred language for descriptions (default: en ) Do not underestimate the power of \"-v\" verbose mode! Try it and see which extra information you can get out of it.","title":"4.1.3 Global Options and Commands"},{"location":"41_mconfig_tool.html#414-shortened-syntax","text":"For quick interactive use, the tool supports a positional argument in the format: [COMPANY:]APPLICATION[:CONFIGNAME[:KEY]] where COMPANY can be empty \"\" to omit the company segment in paths (use leading : e.g. :myapp:settings ). Examples: - mconfig mycompany:myapp:database show (with company) - mconfig :myapp:database show (app-only) Both equivalent to mconfig --company [\"\"\"\"] --app myapp --config database show .","title":"4.1.4 Shortened Syntax"},{"location":"41_mconfig_tool.html#415-environment-variables","text":"The tool automatically picks up the following environment variables if the corresponding options are not provided: - MCONFIG_COMPANY - MCONFIG_APP - MCONFIG_CONFIG","title":"4.1.5 Environment Variables"},{"location":"41_mconfig_tool.html#416-examples","text":"List configurations: mconfig --company mycomp --app myapp list Show effective configuration: mconfig mycomp:myapp:settings show # OR mconfig show --company mycomp --app myapp --config settings Get value and metadata for a specific key: mconfig mycomp:myapp:db:password get Change output to JSON for scripting: mconfig mycomp:myapp:settings show -o JSON See where the values in your configuration are coming from: mconfig mycomp:myapp:settings show -v Set a configuration value: mconfig mycomp:myapp:db:user set --value = \"dbuser\" --scope = USER Update a configuration value with dry-run and validation: mconfig mycomp:myapp:settings:timeout set -V 30 -S HOST -T NUMBER --dry-run Monitor configuration changes: This one's for you, SRE and developers! mconfig mycomp:myapp:settings monitor --dump -v mconfig :myapp:settings monitor --dump -v # app-only App-only examples (omit company segment): mconfig -c \"\" myapp list mconfig :myapp:db get password","title":"4.1.6 Examples"},{"location":"42_logging.html","text":"4.2 Logging in mConfig \u00b6 mConfig uses a custom logging abstraction defined by the ConfigLoggingInterface . This allows the library to remain independent of specific logging frameworks while still providing necessary diagnostic information. Available Implementations \u00b6 Implementation Module Priority Service Name Use Case NullLogging mConfigCore 0 null Default; silent operation. ConsoleLogging mConfigCore 1 console Dev/tests; prints to stdout/stderr. Not for production. Slf4j2Logger mConfigLoggingSlf4j 5 slf4j Production use; forwards to SLF4J. Internal and Hidden Implementations \u00b6 InternalLogger ( mConfigCore , impl.core ): Activated if ConfigFeature.LOGGING_REDIRECT_TARGET is set. Redirects to specified target. Using SLF4J2Logger in Production \u00b6 Slf4j2Logger (priority 5) bridges mConfig logging to SLF4J. 4.2.1 Add Dependencies \u00b6 Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigLoggingSlf4j </artifactId> <version> ${mconfig.version} </version> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigLoggingSlf4j:${mconfig.version}' Note: Also need SLF4J API + impl (e.g., logback-classic). 4.2.2 Auto-Discovery \u00b6 With mConfigLoggingSlf4j on classpath, auto-selected (highest prio). Override with ConfigFactoryBuilder.setFeature(ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB, \"slf4j\") . 4.2.3 Configuration \u00b6 Configure SLF4J via logback.xml , etc. Slf4j2Logger uses logger name from ConfigFactoryBuilder company/app or default \"mConfig\". ConsoleLogging for Development and Tests \u00b6 ConsoleLogging is a lightweight console logger (stdout for lower levels, stderr for WARN/ERROR) for debugging mConfig internals. No external dependencies required. 4.2.4 Build Configuration (Maven & Gradle) \u00b6 To use ConsoleLogging in modules other than mConfigCore , you must include the mConfigCore test-jar dependency in your build: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigCore </artifactId> <version> ${mconfig.version} </version> <type> test-jar </type> <scope> test </scope> </dependency> Gradle: testImplementation 'org.metabit.platform.support.config:mConfigCore:${mconfig.version}:tests' 4.2.5 Manual Activation \u00b6 You can instantiate ConsoleLogging directly and pass it to components. import org.metabit.platform.support.config.impl.logging.ConsoleLogging ; import org.metabit.platform.support.config.ConfigFeature ; // ... in your test ... ConsoleLogging logger = new ConsoleLogging ( \"MyModuleTest\" ); logger . setLevel ( \"DEBUG\" ); // Use with a component that takes a logger component . testComponent ( settings , logger ); 4.2.6 Usage with ConfigFactoryBuilder \u00b6 ConfigFactoryBuilder uses ServiceLoader to discover ConfigLoggingInterface implementations. Note for Modular Projects: ConsoleLogging is fully supported via provides in the mConfigCore module-info.java . To force the use of ConsoleLogging when using ConfigFactoryBuilder in tests, you can set the feature: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"company\" , \"app\" ); builder . setFeature ( ConfigFeature . LOGGING_TO_USE_IN_CONFIGLIB , \"console\" ); This will only work if the ConsoleLogging class is discoverable by ServiceLoader . If discovery fails, it will fall back to NullLogging . Configuration \u00b6 Log Levels \u00b6 Available levels: TRACE , DEBUG , INFO , WARN , ERROR . Default level for ConsoleLogging is INFO . You can set the level via setLevel(String) : logger . setLevel ( \"TRACE\" ); Output Redirection \u00b6 INFO , DEBUG , TRACE are printed to System.out . WARN , ERROR are printed to System.err . How Logging is Discovered and Selected \u00b6 In DefaultConfigFactoryBuilder.findLoggerForConfigUse() : If ConfigFeature.LOGGING_REDIRECT_TARGET is set, instantiate InternalLogger with target and init. Load ServiceLoader<ConfigLoggingInterface> : Prefer exact match to ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB by service name (case-insensitive). Otherwise, select highest priority ( getServiceModulePriority() ) among those that init() successfully. Fallback to NullLogging . All loggers must implement init(ConfigFactorySettings) (usually returns true ) and exit() .","title":"4.2 Logging"},{"location":"42_logging.html#42-logging-in-mconfig","text":"mConfig uses a custom logging abstraction defined by the ConfigLoggingInterface . This allows the library to remain independent of specific logging frameworks while still providing necessary diagnostic information.","title":"4.2 Logging in mConfig"},{"location":"42_logging.html#available-implementations","text":"Implementation Module Priority Service Name Use Case NullLogging mConfigCore 0 null Default; silent operation. ConsoleLogging mConfigCore 1 console Dev/tests; prints to stdout/stderr. Not for production. Slf4j2Logger mConfigLoggingSlf4j 5 slf4j Production use; forwards to SLF4J.","title":"Available Implementations"},{"location":"42_logging.html#internal-and-hidden-implementations","text":"InternalLogger ( mConfigCore , impl.core ): Activated if ConfigFeature.LOGGING_REDIRECT_TARGET is set. Redirects to specified target.","title":"Internal and Hidden Implementations"},{"location":"42_logging.html#using-slf4j2logger-in-production","text":"Slf4j2Logger (priority 5) bridges mConfig logging to SLF4J.","title":"Using SLF4J2Logger in Production"},{"location":"42_logging.html#421-add-dependencies","text":"Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigLoggingSlf4j </artifactId> <version> ${mconfig.version} </version> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigLoggingSlf4j:${mconfig.version}' Note: Also need SLF4J API + impl (e.g., logback-classic).","title":"4.2.1 Add Dependencies"},{"location":"42_logging.html#422-auto-discovery","text":"With mConfigLoggingSlf4j on classpath, auto-selected (highest prio). Override with ConfigFactoryBuilder.setFeature(ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB, \"slf4j\") .","title":"4.2.2 Auto-Discovery"},{"location":"42_logging.html#423-configuration","text":"Configure SLF4J via logback.xml , etc. Slf4j2Logger uses logger name from ConfigFactoryBuilder company/app or default \"mConfig\".","title":"4.2.3 Configuration"},{"location":"42_logging.html#consolelogging-for-development-and-tests","text":"ConsoleLogging is a lightweight console logger (stdout for lower levels, stderr for WARN/ERROR) for debugging mConfig internals. No external dependencies required.","title":"ConsoleLogging for Development and Tests"},{"location":"42_logging.html#424-build-configuration-maven-gradle","text":"To use ConsoleLogging in modules other than mConfigCore , you must include the mConfigCore test-jar dependency in your build: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigCore </artifactId> <version> ${mconfig.version} </version> <type> test-jar </type> <scope> test </scope> </dependency> Gradle: testImplementation 'org.metabit.platform.support.config:mConfigCore:${mconfig.version}:tests'","title":"4.2.4 Build Configuration (Maven &amp; Gradle)"},{"location":"42_logging.html#425-manual-activation","text":"You can instantiate ConsoleLogging directly and pass it to components. import org.metabit.platform.support.config.impl.logging.ConsoleLogging ; import org.metabit.platform.support.config.ConfigFeature ; // ... in your test ... ConsoleLogging logger = new ConsoleLogging ( \"MyModuleTest\" ); logger . setLevel ( \"DEBUG\" ); // Use with a component that takes a logger component . testComponent ( settings , logger );","title":"4.2.5 Manual Activation"},{"location":"42_logging.html#426-usage-with-configfactorybuilder","text":"ConfigFactoryBuilder uses ServiceLoader to discover ConfigLoggingInterface implementations. Note for Modular Projects: ConsoleLogging is fully supported via provides in the mConfigCore module-info.java . To force the use of ConsoleLogging when using ConfigFactoryBuilder in tests, you can set the feature: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"company\" , \"app\" ); builder . setFeature ( ConfigFeature . LOGGING_TO_USE_IN_CONFIGLIB , \"console\" ); This will only work if the ConsoleLogging class is discoverable by ServiceLoader . If discovery fails, it will fall back to NullLogging .","title":"4.2.6 Usage with ConfigFactoryBuilder"},{"location":"42_logging.html#configuration","text":"","title":"Configuration"},{"location":"42_logging.html#log-levels","text":"Available levels: TRACE , DEBUG , INFO , WARN , ERROR . Default level for ConsoleLogging is INFO . You can set the level via setLevel(String) : logger . setLevel ( \"TRACE\" );","title":"Log Levels"},{"location":"42_logging.html#output-redirection","text":"INFO , DEBUG , TRACE are printed to System.out . WARN , ERROR are printed to System.err .","title":"Output Redirection"},{"location":"42_logging.html#how-logging-is-discovered-and-selected","text":"In DefaultConfigFactoryBuilder.findLoggerForConfigUse() : If ConfigFeature.LOGGING_REDIRECT_TARGET is set, instantiate InternalLogger with target and init. Load ServiceLoader<ConfigLoggingInterface> : Prefer exact match to ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB by service name (case-insensitive). Otherwise, select highest priority ( getServiceModulePriority() ) among those that init() successfully. Fallback to NullLogging . All loggers must implement init(ConfigFactorySettings) (usually returns true ) and exit() .","title":"How Logging is Discovered and Selected"},{"location":"43_faq.html","text":"4.3 FAQ - Frequently Asked Questions \u00b6 4.3.1 I want to... \u00b6 I want to extract a subconfiguration to a Properties object. \u00b6 If your configuration contains a subset of entries, say, for an existing Java component which expects them that way, and you just want to get an pass them on, then ConfigUtil.copyPrefixedEntriesToJavaProperties() is what should help you. You specify the prefix, including possible \".\" from the hierarchy, and get a java.util.Properties instance with all the contents from the Configuration which start with the prefix. The prefix is removed automatically. Caveat: This will skip configuration layers where the source does not allow enumeration of its contents. So the result of this call may yield results different from what you'd get if you were using the Configuration itself! Recommendation: If that subconfig can be limited in what it may and should contain, please consider using a ConfigScheme (in addition, or instead). Also, have a look at other methods in the ConfigUtil class, for similar use cases. I want to know where my configuration files are located. \u00b6 Use the mConfigTool provided. It can tell you the general search paths (potential locations), as well as the actual locations of the files it found, and where the values in individual entries come from. 4.3.2 Why is... \u00b6 Why can't I state my defaults right at the place I'm asking for the value? \u00b6 This approach sounds simpler - getInteger(\"weightInTons\",5) looks good at first sight. Until you realize what happens when you ask for this value a second time, or a third... Also, this prevents you from generating a proper documentation of your configuration parameters. ConfigSchemes should not be hard to use. Try them, please. But if you insist on using the old way, there is the mConfigCheese module - for those who like their code a bit pungent. 4.3.3 How can I fix... \u00b6 Quick Verification Checklist \u00b6 If it's not working yet: Place a test config file: Create ~/.config/myCompany/myApplication/network.properties (Linux/Mac) or %APPDATA%\\myCompany\\myApplication\\network.properties (Windows): peer = localhost port = 8080 probability = 0.5 List discovered configs: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { factory . listAvailableConfigurations (). forEach ( System . out :: println ); } Enable logging: Add mConfigLoggingSlf4j dep + SLF4J config (see No mConfig logging output below). Use mConfigTool CLI: mconfig myCompany:myApplication get network.peer -v (requires building mConfigTools; see mConfigTools README ). See detailed troubleshooting sections below. Updates to config files are not detected \u00b6 You are not buffering the results in some local variables, are you? Your own variables are not updated by mConfig. Ask the Configuration object for the value instead whenever you need it. Are the directories and files accessible for the account the program runs as? mConfig needs to be able to list directory contents and read config files; inaccessible dirs and files cause debug messages at most, but no error. The cache setting doesn't match with your expected reaction time. For efficiency, files are not checked and re-read on every config value access. There is a delay between checks. If the default value (2 seconds) is too long for your purposes, you can change it. @TODO name the config settings key. Keep in mind a higher update frequency increases overhead. Is the format supported? You can choose and combine mconfig Format modules; if the file extension pattern of the config file does not match with a file format present in your current build, it won't be read. JPMS Module Access Errors \u00b6 If your application uses JPMS (named module-info.java ) but omits requires for mConfig modules, you will see access errors. Compile-time (javac): cannot access metabit.mconfig.core.ConfigFactory module your.module does not read module metabit.mconfig.core Runtime (java): java.lang.IllegalAccessError: class your.package.YourClass cannot access class metabit.mconfig.core.ConfigFactory (in module metabit.mconfig.core) because module your.module does not read module metabit.mconfig.core Fix: Add the required requires directives to your module-info.java . The list depends on the mConfig variant: mConfigFull (JPMS requires section) mConfigStandard (JPMS requires section) See also JPMS introduction . Config values always returning defaults or null \u00b6 Symptoms: Calls like cfg.getString(\"key\") return null or scheme defaults; no exceptions or warnings. Common causes: - Mismatched company , application , or configName (case-sensitive). - No config files in standard locations (classpath src/main/resources/.config/<company>/<app>/<configName>.properties or filesystem equivalents). - File extension not matching available formats (e.g., .yaml without YAML format module). - Permissions issues on directories/files (check logs). Fix steps: 1. Use factory.listAvailableConfigurations() to list discovered configs and their sources. 2. Run mConfigTool CLI for full diagnostics: paths searched, files found, entry origins. 3. Verify placements per Getting Started . 4. Add missing format modules (e.g., mConfigFormatYAMLwithJackson for YAML). Tests not loading expected configurations \u00b6 Symptoms: Unit/integration tests use production defaults or empty configs despite setTestMode(true) . Causes: - Missing ConfigFactoryBuilder.setTestMode(true) before build() . - Test files not in correct locations. - forbidTestMode() called or PERMIT_TEST_MODE=false . Fix: 1. Add @BeforeAll static void setup() { ConfigFactoryBuilder.setTestMode(true); } 2. Place files in: - src/test/resources/.config/<company>/<app>/<configName>.ext (preferred) - src/test/resources/config/<SCOPE> (e.g., USER ) 3. Custom: ConfigFactoryBuilder.setFeature(ConfigFeature.TESTMODE_DIRECTORIES, List.of(\"USER:src/test/configs\")); 4. See full details in Test Mode . No mConfig logging output \u00b6 Symptoms: Silent on config discovery, errors, or debug info. Fix: 1. Add dependency: mConfigLoggingSlf4j . 2. Configure SLF4J backend (e.g., Logback logback.xml ): <logger name= \"metabit.config\" level= \"DEBUG\" /> 3. Ensure SLF4J implementation (logback-classic, log4j-slf4j) on classpath. See Logging . Environment variables don't provide config values \u00b6 Symptoms: Env vars like myapp-network-peer=localhost ignored. Fix: 1. Add mConfigSourceEnvVar dependency. 2. Use naming scheme: <application>_<configName>_<key> (lowercase, e.g., myapp_network_peer ). 3. Scope: SESSION (overrides USER). 4. Verify via mConfigTool or enable logging. See mConfigSourceEnvVar README .","title":"4.3 FAQ"},{"location":"43_faq.html#43-faq-frequently-asked-questions","text":"","title":"4.3 FAQ - Frequently Asked Questions"},{"location":"43_faq.html#431-i-want-to","text":"","title":"4.3.1 I want to..."},{"location":"43_faq.html#i-want-to-extract-a-subconfiguration-to-a-properties-object","text":"If your configuration contains a subset of entries, say, for an existing Java component which expects them that way, and you just want to get an pass them on, then ConfigUtil.copyPrefixedEntriesToJavaProperties() is what should help you. You specify the prefix, including possible \".\" from the hierarchy, and get a java.util.Properties instance with all the contents from the Configuration which start with the prefix. The prefix is removed automatically. Caveat: This will skip configuration layers where the source does not allow enumeration of its contents. So the result of this call may yield results different from what you'd get if you were using the Configuration itself! Recommendation: If that subconfig can be limited in what it may and should contain, please consider using a ConfigScheme (in addition, or instead). Also, have a look at other methods in the ConfigUtil class, for similar use cases.","title":"I want to extract a subconfiguration to a Properties object."},{"location":"43_faq.html#i-want-to-know-where-my-configuration-files-are-located","text":"Use the mConfigTool provided. It can tell you the general search paths (potential locations), as well as the actual locations of the files it found, and where the values in individual entries come from.","title":"I want to know where my configuration files are located."},{"location":"43_faq.html#432-why-is","text":"","title":"4.3.2 Why is..."},{"location":"43_faq.html#why-cant-i-state-my-defaults-right-at-the-place-im-asking-for-the-value","text":"This approach sounds simpler - getInteger(\"weightInTons\",5) looks good at first sight. Until you realize what happens when you ask for this value a second time, or a third... Also, this prevents you from generating a proper documentation of your configuration parameters. ConfigSchemes should not be hard to use. Try them, please. But if you insist on using the old way, there is the mConfigCheese module - for those who like their code a bit pungent.","title":"Why can't I state my defaults right at the place I'm asking for the value?"},{"location":"43_faq.html#433-how-can-i-fix","text":"","title":"4.3.3 How can I fix..."},{"location":"43_faq.html#quick-verification-checklist","text":"If it's not working yet: Place a test config file: Create ~/.config/myCompany/myApplication/network.properties (Linux/Mac) or %APPDATA%\\myCompany\\myApplication\\network.properties (Windows): peer = localhost port = 8080 probability = 0.5 List discovered configs: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"myCompany\" , \"myApplication\" ). build ()) { factory . listAvailableConfigurations (). forEach ( System . out :: println ); } Enable logging: Add mConfigLoggingSlf4j dep + SLF4J config (see No mConfig logging output below). Use mConfigTool CLI: mconfig myCompany:myApplication get network.peer -v (requires building mConfigTools; see mConfigTools README ). See detailed troubleshooting sections below.","title":"Quick Verification Checklist"},{"location":"43_faq.html#updates-to-config-files-are-not-detected","text":"You are not buffering the results in some local variables, are you? Your own variables are not updated by mConfig. Ask the Configuration object for the value instead whenever you need it. Are the directories and files accessible for the account the program runs as? mConfig needs to be able to list directory contents and read config files; inaccessible dirs and files cause debug messages at most, but no error. The cache setting doesn't match with your expected reaction time. For efficiency, files are not checked and re-read on every config value access. There is a delay between checks. If the default value (2 seconds) is too long for your purposes, you can change it. @TODO name the config settings key. Keep in mind a higher update frequency increases overhead. Is the format supported? You can choose and combine mconfig Format modules; if the file extension pattern of the config file does not match with a file format present in your current build, it won't be read.","title":"Updates to config files are not detected"},{"location":"43_faq.html#jpms-module-access-errors","text":"If your application uses JPMS (named module-info.java ) but omits requires for mConfig modules, you will see access errors. Compile-time (javac): cannot access metabit.mconfig.core.ConfigFactory module your.module does not read module metabit.mconfig.core Runtime (java): java.lang.IllegalAccessError: class your.package.YourClass cannot access class metabit.mconfig.core.ConfigFactory (in module metabit.mconfig.core) because module your.module does not read module metabit.mconfig.core Fix: Add the required requires directives to your module-info.java . The list depends on the mConfig variant: mConfigFull (JPMS requires section) mConfigStandard (JPMS requires section) See also JPMS introduction .","title":"JPMS Module Access Errors"},{"location":"43_faq.html#config-values-always-returning-defaults-or-null","text":"Symptoms: Calls like cfg.getString(\"key\") return null or scheme defaults; no exceptions or warnings. Common causes: - Mismatched company , application , or configName (case-sensitive). - No config files in standard locations (classpath src/main/resources/.config/<company>/<app>/<configName>.properties or filesystem equivalents). - File extension not matching available formats (e.g., .yaml without YAML format module). - Permissions issues on directories/files (check logs). Fix steps: 1. Use factory.listAvailableConfigurations() to list discovered configs and their sources. 2. Run mConfigTool CLI for full diagnostics: paths searched, files found, entry origins. 3. Verify placements per Getting Started . 4. Add missing format modules (e.g., mConfigFormatYAMLwithJackson for YAML).","title":"Config values always returning defaults or null"},{"location":"43_faq.html#tests-not-loading-expected-configurations","text":"Symptoms: Unit/integration tests use production defaults or empty configs despite setTestMode(true) . Causes: - Missing ConfigFactoryBuilder.setTestMode(true) before build() . - Test files not in correct locations. - forbidTestMode() called or PERMIT_TEST_MODE=false . Fix: 1. Add @BeforeAll static void setup() { ConfigFactoryBuilder.setTestMode(true); } 2. Place files in: - src/test/resources/.config/<company>/<app>/<configName>.ext (preferred) - src/test/resources/config/<SCOPE> (e.g., USER ) 3. Custom: ConfigFactoryBuilder.setFeature(ConfigFeature.TESTMODE_DIRECTORIES, List.of(\"USER:src/test/configs\")); 4. See full details in Test Mode .","title":"Tests not loading expected configurations"},{"location":"43_faq.html#no-mconfig-logging-output","text":"Symptoms: Silent on config discovery, errors, or debug info. Fix: 1. Add dependency: mConfigLoggingSlf4j . 2. Configure SLF4J backend (e.g., Logback logback.xml ): <logger name= \"metabit.config\" level= \"DEBUG\" /> 3. Ensure SLF4J implementation (logback-classic, log4j-slf4j) on classpath. See Logging .","title":"No mConfig logging output"},{"location":"43_faq.html#environment-variables-dont-provide-config-values","text":"Symptoms: Env vars like myapp-network-peer=localhost ignored. Fix: 1. Add mConfigSourceEnvVar dependency. 2. Use naming scheme: <application>_<configName>_<key> (lowercase, e.g., myapp_network_peer ). 3. Scope: SESSION (overrides USER). 4. Verify via mConfigTool or enable logging. See mConfigSourceEnvVar README .","title":"Environment variables don't provide config values"},{"location":"44_design_consolidated.html","text":"4.4 mConfig Consolidated Design Document \u00b6 4.4.1 Overview \u00b6 mConfig is a modular configuration library for Java, designed for flexibility, extensibility, and standardized configuration management across different operating systems and environments. 4.4.1.1 Multi-Platform Portability Goal \u00b6 While the primary implementation is in Java, mConfig is designed with future ports to other languages (e.g., C, Rust, Python) in mind. - Abstraction over Platform Specifics : Core logic (in mConfigCore ) MUST remain agnostic of specific packaging formats (like JARs) or environment-specific APIs (like Java ClassLoaders). - Module Isolation : Platform-specific logic (e.g., scanning Java classpath for resources) must be isolated in dedicated modules (like mConfigSourceJAR ). - Standardized Interfaces : Use generic interfaces for discovery and storage to ensure that the core behavior can be mirrored in other language environments without significant architectural changes. Core Architectural Principle: Layered Stack \u00b6 Configurations are resolved through a stack of layers, prioritized by scope specificity. Cache (optional) -> Found Sources (ordered by scope) -> Defaults 4.4.2 Scopes and Priority \u00b6 Scopes define the visibility and precedence of configuration data. Scope Description Priority POLICY Enforced policy settings (e.g., GPO), overriding everything else. 1 (Highest) RUNTIME Volatile, in-memory settings for the current process. 2 SESSION Specific to the current user session or working directory. 3 USER Personal settings for the current user (e.g., ~/.config/ ). 4 APPLICATION Settings specific to the application installation/portable root. 5 HOST Host / OS instance settings (e.g., /etc/ , Windows Registry HKLM). 6 CLUSTER Settings for a cluster of hosts. 7 CLOUD Cloud-based configurations, shared across multiple clusters. 8 ORGANIZATION Settings shared across an organization/licensee. 9 PRODUCT Hardcoded defaults provided by the application or modules. 10 (Lowest) Tie-breaking within the same scope: Later-added layers take precedence over earlier-added ones. 4.4.2.1 Storage Type Priority \u00b6 Resolution priority between different storage types (within the same scope) is deterministic. Default Order (Highest to Lowest): 1. RAM (In-memory overrides) 2. secrets (Encrypted/sensitive data) 3. files (Local filesystem) 4. registry (Windows Registry - JNR-FFI) 5. registryjni (Windows Registry - JNI) 6. zookeeper (ZooKeeper - Experimental, Self-configuring) 7. JAR (Classpath resources/defaults) This order can be customized via STORAGE_TYPE_PRIORITIES (List of IDs) and STORAGE_TYPE_ALLOW_ALL_STORAGES (Boolean). 4.4.2.2 Self-Configuration \u00b6 mConfig supports \"self-configuration\" to allow the library to configure its own behavior using the same discovery mechanisms it provides to applications. 4.4.2.2.1 Library Self-Configuration (ConfigFactorySettings) \u00b6 When the mConfigSourceJAR module is present, mConfig automatically searches for a properties file named mconfig.properties in the following classpath location: .config/metabit/mConfig/mconfig.properties This file is used to populate ConfigFactorySettings during the ConfigFactory initialization. It supports setting any ConfigFeature . (Thus, handle with care; it is as powerful as its code counterparts.) Discovery : It uses ClassLoader.getResources() to find all occurrences of this file in the classpath, allowing settings to be provided from multiple JARs or resource paths. Format : Standard Java .properties format only. Keys (ignoring case) are matched against ConfigFeature constants. Disabling : This feature is enabled by default for convenience, but can be disabled via ConfigFeature.ENABLE_SELF_CONFIGURATION = false for environments with strict classpath security requirements. 4.4.2.2.2 Networked Source Self-Configuration \u00b6 Networked sources (like ZooKeeper) can also retrieve their own connection settings (connect string, root path, etc.) from previously loaded layers (e.g., JAR defaults or local filesystem overrides). Resolution Order during Startup: 1. Core Discovery : Modules (Storages, Formats) and ConfigFactoryComponent s are identified. 2. Library Self-Configuration : SelfConfigurationComponent (from mConfigSourceJAR ) is initialized, populating ConfigFactorySettings from mconfig.properties . 3. Local Source Initialization : JARConfigSource and FileConfigStorage are initialized based on STORAGE_TYPE_PRIORITIES . 4. Networked Source Initialization : - ZooKeeperConfigStorage.init() is called. - It requests its own configuration (default name: \"zookeeper\" ) from the factory via ctx.getFactory().getConfig(\"zookeeper\") . - If settings are found in JAR defaults or local files, it connects and registers its locations (e.g., CLUSTER , ORGANIZATION ). - If settings are missing, it remains inactive (zero-config support). 5. Finalization : The factory is ready, including any successfully activated networked layers. See ZooKeeper Example for detailed configuration snippets. 4.4.3 Core Components \u00b6 ConfigFactory \u00b6 The main entry point. It manages the ConfigSearchList and instantiates Configuration objects. ConfigSearchList \u00b6 A prioritized list of ConfigLocation entries defining where the library should look for configurations. ConfigLocation & ConfigSource \u00b6 ConfigLocation : Defines where a configuration might be found (Storage + Handle + Scope). ConfigSource : An instantiated ConfigLocation that is associated with a specific ConfigLayer . It confirms the configuration exists and is readable. ConfigStorage \u00b6 Provides low-level access to data (e.g., FileConfigStorage , WindowsRegistryConfigStorage , EnvVarConfigStorage ). ConfigFormat \u00b6 Parses and writes data in specific formats (e.g., Properties , JSON , YAML , TOML , JSON5 , INI ). It is responsible for instantiating ConfigLayer objects. ConfigLayer \u00b6 A concrete instance of configuration data from a ConfigLocation . It maps hierarchical keys (e.g., database/host ) to ConfigEntry objects. ConfigEntry \u00b6 A leaf node in the configuration tree, containing the value and metadata (like the source location). 4.4.4 Operational Modes \u00b6 TEST_MODE \u00b6 Bypasses standard OS locations. Uses only explicitly provided test paths (via TESTMODE_DIRECTORIES feature) and standard test resources. TESTMODE_DIRECTORIES entries support the SCOPENAME \":\" PATH format. Prevents tests from interfering with or relying on actual user configurations. Security : Employs a two-tier gate system (Global Static Gate + Instance Dynamic Gate). PERMIT_TEST_MODE defaults to true (\"Productive by Default\") but can be locked down per instance. ADDITIONAL_DIRECTORIES \u00b6 ADDITIONAL_RUNTIME_DIRECTORIES and ADDITIONAL_USER_DIRECTORIES allow adding custom search paths at runtime. Support the SCOPENAME \":\" PATH format, allowing paths to be assigned to any scope (not just their default scope). Prepended to the search list of their respective scope, ensuring they take precedence over default locations. SERVICE-mode (Auto-refresh & Monitoring) \u00b6 If enabled, every access re-checks the search list for new or updated configuration files. Recommended to be used with a Cache Layer to mitigate performance overhead. Cache entries should have a configurable TTL (Time-To-Live). Monitoring Support : Configuration supports the subscribeToUpdates(Consumer<ConfigLocation>) mechanism. This is used by the monitor CLI command to provide real-time reporting of changes. 4.4.4.2 Self-Configuration Security \u00b6 Self-configuration (see section 2.2.1) automatically applies settings from the classpath. In environments where the classpath might contain untrusted JARs, this feature can be disabled: ConfigFactoryBuilder . create ( \"metabit\" , \"APP\" ) . setFeature ( ConfigFeature . ENABLE_SELF_CONFIGURATION , false ) . build (); Disabling self-configuration ensures that the ConfigFactory starts with only the settings explicitly provided in code, preventing \"configuration injection\" via the classpath. 4.4.5 Reading and Writing \u00b6 Reading \u00b6 Sequential search from most specific to least specific scope. Value conversion (String to Integer, Boolean, etc.) is handled at the Configuration facade level. Writing \u00b6 Direct Write : Attempt to write back to the ConfigLocation where the entry was found. Scope-based Write : Specify a scope for the write operation. Write Fallback (Fall-forward) : If writing to the preferred location fails, attempt to write to a more specific scope (e.g., if MACHINE is read-only, write to USER). Write Cache : Optional layer that buffers writes until a flush() is called. 4.4.6 Security and Secrets \u00b6 mConfig provides specialized handling for sensitive data (API keys, passwords, certificates). 4.4.6.1 Secret Entries \u00b6 Sensitive data should be handled via SecretValue and SecretConfigEntryLeaf . Values are obfuscated in memory ( char[] or byte[] instead of String where possible). toString() implementation of secret entries is automatically redacted ( [REDACTED] ). ConfigFacadeImpl.getSecret(key) is the preferred API to retrieve a SecretValue . 4.4.6.2 Scheme-Driven Secrets \u00b6 A ConfigEntry is treated as a secret if its ConfigEntrySpecification (from a ConfigScheme ) has the SECRET flag set. - ConfigEntryFactory automatically creates a SecretConfigEntryLeaf if the scheme marks the key as a secret. - Intelligent Type Selection : When creating a secret entry, the factory chooses a SecretType (e.g., PLAIN_TEXT vs SYMMETRIC_KEY ) based on the requested ConfigEntryType . 4.4.6.3 External Secrets Providers \u00b6 External authentication (e.g., towards networked sources like HashiCorp Vault) can be integrated via specialized modules implementing ConfigSecretsProviderInterface . - Secret providers are initialized during the configuration loading phase. - They can receive a ConfigurationPhaseWrapper to access partially loaded configurations for their own initialization (e.g., to read the Vault address from a local file). 4.4.7 Format Specifics \u00b6 Java .properties \u00b6 Flat key-value pairs. Trims whitespace. Supports multi-line values with \\ . JSON / JSON5 \u00b6 Toplevel must be an Object or Array. JSON5 adds support for comments, trailing commas, and unquoted keys. YAML \u00b6 Supports hierarchical structures. Implementation must ensure secure parsing (avoiding arbitrary command execution). INI \u00b6 Section-based ( [section] ). Hierarchical keys can be mapped to sections using / (e.g., [first/second] ). 4.4.7.7 Writing Priorities \u00b6 When writing to a configuration (e.g., via put ), mConfig applies the following priorities within the requested scope(s): Priority 1: Update Existing Entry. The highest-priority writeable layer in the scope that already contains the key is updated. Priority 2: Add to Existing Layer. If the key is new to the scope, it is added to the highest-priority writeable layer already instantiated in that scope. Priority 3: Create New Layer. If no writeable layers exist for the scope, mConfig attempts to create a new one using the prioritized ConfigStorage and ConfigFormat settings. Writes are strictly scope-isolated unless WRITE_FALLBACK_ACROSS_SCOPES is enabled. For multi-scope writes, mConfig iterates from the most specific to the most generic scope, stopping at the first successful write. 4.4.8 BLOBs (Binary Data) \u00b6 mConfig supports Binary Large Objects (certs, licenses, keys) in two distinct ways: 4.4.8.1 Hierarchical BLOBs (Keyed Leaves) \u00b6 In hierarchical formats like JSON and YAML, binary data can exist as a leaf node with a specific key (e.g., server/certificate ). - YAML : Native support via the !!binary tag. - JSON : Supported via Base64 encoding. If a ConfigScheme marks a key as BYTES , the JSON format will automatically decode the Base64 string into a BlobConfigEntryLeaf . - These entries are part of the regular configuration tree and can be accessed via getValueAsBytes() . 4.4.8.2 Flat BLOBs (Opaque Files) \u00b6 Entire files can be treated as a single binary blob using the FileRawBinaryFormat (extension .bin ). - These are opaque and have no internal structure. - The entry is always accessed using the empty string key ( \"\" ). - Requesting any other key from a flat binary layer will return null . 4.4.9 Crypto Library Interaction \u00b6 mConfig is designed to work seamlessly with standard Java crypto libraries (JCE) and third-party libraries like BouncyCastle. JCE Integration : SecretValue can store raw bytes of PrivateKey , PublicKey , or SecretKey . Conversion typically involves key.getEncoded() . BouncyCastle : Can be used to process SecretValue contents (e.g., parsing a PEM-encoded certificate stored as a BYTES entry). Test Strategy : Integration tests ( SecretsJCETest , SecretsBCTest ) verify that low-level binary secrets are preserved exactly as they move through the configuration stack. 4.4.10 Configuration Schemes \u00b6 Configuration Schemes define the contract for a set of configuration entries, specifying keys, types, defaults, and validation rules. See the detailed Configuration Schemes for information on: - Scheme structure and properties - Future-proofing with the MANDATORY block - JSON format variants - Discovery and registration via ConfigSchemeRepository 4.4.10.1 Discovery and Precedence \u00b6 Schemes are automatically discovered from the classpath (specifically within .config/ directories) if the JARConfigSource is active. Unified Discovery: Discovery is performed across all classpath resources, including both main and test resource directories. Precedence: If multiple scheme files for the same configuration name are discovered, a \"Last-One-Wins\" strategy is applied based on the order returned by the ClassLoader . In typical development environments (Maven/Gradle), this means production resources might overwrite test resources if they appear later in the classpath enumeration. Scope Agnosticism: Unlike configuration data (layers), schemes are not scope-isolated in TEST_MODE . Production schemes are always loaded to ensure a consistent contract. 4.4.10.2 Discovery and Binding Flow (Mermaid) \u00b6 The following diagram illustrates how schemes are discovered by storages, registered in the factory, and finally bound to configuration instances. sequenceDiagram participant S as ConfigStorage (e.g. JAR) participant C as ConfigFactoryInstanceContext participant F as ConfigFactory participant L as LayeredConfiguration participant DL as DefaultLayer Note over S, C: Discovery Phase (during Storage.init) S->>C: registerDiscoveredScheme(name, json) Note over C, F: Registration Phase (during Factory.init) F->>C: getDiscoveredSchemes() F->>F: addConfigScheme(name, scheme) Note over F, L: Binding Phase (during factory.getConfig) F->>L: instantiate with matching scheme L->>DL: transferDefaults(scheme) Layered Configuration (Mermaid) \u00b6 %%{init: {'theme':'neutral'}}%% erDiagram Configuration ||--|| BasicConfiguration : \"facade for\" BasicConfiguration ||--|| LayeredConfiguration : \"implemented by\" LayeredConfiguration ||--o| CacheLayer : \"at top\" LayeredConfiguration ||--o{ ConfigSource : \"stacked in the middle\" LayeredConfiguration ||--|| DefaultLayer : \"at bottom\" LayeredConfiguration ||--o| ConfigScheme : \"bound to\" ConfigScheme ||--|| DefaultLayer : \"populates\" ConfigScheme ||--o{ ConfigEntrySpecification : \"contains\" ConfigEntry }|--o| ConfigEntrySpecification : \"validated by\" ConfigSource }|--|| ConfigScope : \"belongs to\" ConfigSource ||--|| ConfigLocation : \"where to look\" ConfigSource }o--|| ConfigStorage : \"how to access\" ConfigSource }o--|{ ConfigFormat : \"maps paths to entries\" 4.4.11 Extending mConfig \u00b6 4.4.11.1 Adding New Storages \u00b6 This is intended for library maintainers extending mConfig with new backends (e.g., databases, cloud stores). When implementing a new ConfigStorage : Module Creation : Create mConfigSource<Name> module with ConfigStorageInterface impl. init(ctx) : Populate ctx.getSearchList() with ConfigLocationImpl for scopes/formats/paths. Read Layers : In tryToReadConfigurationLayers , load/parse entries into LayeredConfiguration . Classpath Order : Auto-discovered; control via ConfigFeature.STORAGE_TYPE_PRIORITIES . Testing : Add unit/integration tests; verify with full mvn clean test . Examples: FileConfigStorage , JARConfigSource , WindowsRegistryConfigSource . In case a specific config format is to be supported as well, it can go into the same module. 4.4.11.2 Adding New ConfigFeatures \u00b6 This is not for library consumers; only project owners should need to perform this step. When adding a new constant to the ConfigFeature enum in mConfigCore , you MUST perform the following steps to ensure technical consistency and avoid runtime errors: Enum Constant : Add the new constant to the ConfigFeature enum. Type Initialization : In the static initialization block of ConfigFeature , you MUST assign a ValueType to the valueType field of the new constant. Example: REGISTRY_BASE_PATH.valueType = ValueType.STRING; Default Values (Optional) : If the feature should have a default value, assign it to the defaultValue field in the same static block. Example: MY_FEATURE.defaultValue = Boolean.TRUE; Verification : Run the ConfigFeatureTypesTest unit test to ensure that all features have a valid type assigned. A missing type will cause a NullPointerException when the feature is accessed via ConfigFactorySettings . 4.4.12 Best Practices \u00b6 Classpath Layout \u00b6 Production Defaults : src/main/resources/.config/&lt;company&gt;/&lt;app&gt;/&lt;config&gt;.&lt;ext&gt; (JARConfigSource). Test Mode : src/test/resources/.config/&lt;company&gt;/&lt;app&gt;/ + config/{SCOPE} (overrides project). Schemes : Same path + .scheme.json . Logging \u00b6 Implement ConfigLoggingInterface for structured logs (SLF4J/JUL/Logback). Avoid : System.out.println (blocks UI/threads). Secrets auto-redacted. Secrets Handling \u00b6 Retrieve: SecretValue sv = config.getSecret(key) (scheme-marked SECRET). Use: byte[] data = sv.getValue() ; sv.erase() post-use (secure wipe). Storage: Formats preserve SecretValue ; logs masked. See Handling Secrets .","title":"4.4 Design Consolidated"},{"location":"44_design_consolidated.html#44-mconfig-consolidated-design-document","text":"","title":"4.4 mConfig Consolidated Design Document"},{"location":"44_design_consolidated.html#441-overview","text":"mConfig is a modular configuration library for Java, designed for flexibility, extensibility, and standardized configuration management across different operating systems and environments.","title":"4.4.1 Overview"},{"location":"44_design_consolidated.html#4411-multi-platform-portability-goal","text":"While the primary implementation is in Java, mConfig is designed with future ports to other languages (e.g., C, Rust, Python) in mind. - Abstraction over Platform Specifics : Core logic (in mConfigCore ) MUST remain agnostic of specific packaging formats (like JARs) or environment-specific APIs (like Java ClassLoaders). - Module Isolation : Platform-specific logic (e.g., scanning Java classpath for resources) must be isolated in dedicated modules (like mConfigSourceJAR ). - Standardized Interfaces : Use generic interfaces for discovery and storage to ensure that the core behavior can be mirrored in other language environments without significant architectural changes.","title":"4.4.1.1 Multi-Platform Portability Goal"},{"location":"44_design_consolidated.html#core-architectural-principle-layered-stack","text":"Configurations are resolved through a stack of layers, prioritized by scope specificity. Cache (optional) -> Found Sources (ordered by scope) -> Defaults","title":"Core Architectural Principle: Layered Stack"},{"location":"44_design_consolidated.html#442-scopes-and-priority","text":"Scopes define the visibility and precedence of configuration data. Scope Description Priority POLICY Enforced policy settings (e.g., GPO), overriding everything else. 1 (Highest) RUNTIME Volatile, in-memory settings for the current process. 2 SESSION Specific to the current user session or working directory. 3 USER Personal settings for the current user (e.g., ~/.config/ ). 4 APPLICATION Settings specific to the application installation/portable root. 5 HOST Host / OS instance settings (e.g., /etc/ , Windows Registry HKLM). 6 CLUSTER Settings for a cluster of hosts. 7 CLOUD Cloud-based configurations, shared across multiple clusters. 8 ORGANIZATION Settings shared across an organization/licensee. 9 PRODUCT Hardcoded defaults provided by the application or modules. 10 (Lowest) Tie-breaking within the same scope: Later-added layers take precedence over earlier-added ones.","title":"4.4.2 Scopes and Priority"},{"location":"44_design_consolidated.html#4421-storage-type-priority","text":"Resolution priority between different storage types (within the same scope) is deterministic. Default Order (Highest to Lowest): 1. RAM (In-memory overrides) 2. secrets (Encrypted/sensitive data) 3. files (Local filesystem) 4. registry (Windows Registry - JNR-FFI) 5. registryjni (Windows Registry - JNI) 6. zookeeper (ZooKeeper - Experimental, Self-configuring) 7. JAR (Classpath resources/defaults) This order can be customized via STORAGE_TYPE_PRIORITIES (List of IDs) and STORAGE_TYPE_ALLOW_ALL_STORAGES (Boolean).","title":"4.4.2.1 Storage Type Priority"},{"location":"44_design_consolidated.html#4422-self-configuration","text":"mConfig supports \"self-configuration\" to allow the library to configure its own behavior using the same discovery mechanisms it provides to applications.","title":"4.4.2.2 Self-Configuration"},{"location":"44_design_consolidated.html#44221-library-self-configuration-configfactorysettings","text":"When the mConfigSourceJAR module is present, mConfig automatically searches for a properties file named mconfig.properties in the following classpath location: .config/metabit/mConfig/mconfig.properties This file is used to populate ConfigFactorySettings during the ConfigFactory initialization. It supports setting any ConfigFeature . (Thus, handle with care; it is as powerful as its code counterparts.) Discovery : It uses ClassLoader.getResources() to find all occurrences of this file in the classpath, allowing settings to be provided from multiple JARs or resource paths. Format : Standard Java .properties format only. Keys (ignoring case) are matched against ConfigFeature constants. Disabling : This feature is enabled by default for convenience, but can be disabled via ConfigFeature.ENABLE_SELF_CONFIGURATION = false for environments with strict classpath security requirements.","title":"4.4.2.2.1 Library Self-Configuration (ConfigFactorySettings)"},{"location":"44_design_consolidated.html#44222-networked-source-self-configuration","text":"Networked sources (like ZooKeeper) can also retrieve their own connection settings (connect string, root path, etc.) from previously loaded layers (e.g., JAR defaults or local filesystem overrides). Resolution Order during Startup: 1. Core Discovery : Modules (Storages, Formats) and ConfigFactoryComponent s are identified. 2. Library Self-Configuration : SelfConfigurationComponent (from mConfigSourceJAR ) is initialized, populating ConfigFactorySettings from mconfig.properties . 3. Local Source Initialization : JARConfigSource and FileConfigStorage are initialized based on STORAGE_TYPE_PRIORITIES . 4. Networked Source Initialization : - ZooKeeperConfigStorage.init() is called. - It requests its own configuration (default name: \"zookeeper\" ) from the factory via ctx.getFactory().getConfig(\"zookeeper\") . - If settings are found in JAR defaults or local files, it connects and registers its locations (e.g., CLUSTER , ORGANIZATION ). - If settings are missing, it remains inactive (zero-config support). 5. Finalization : The factory is ready, including any successfully activated networked layers. See ZooKeeper Example for detailed configuration snippets.","title":"4.4.2.2.2 Networked Source Self-Configuration"},{"location":"44_design_consolidated.html#443-core-components","text":"","title":"4.4.3 Core Components"},{"location":"44_design_consolidated.html#configfactory","text":"The main entry point. It manages the ConfigSearchList and instantiates Configuration objects.","title":"ConfigFactory"},{"location":"44_design_consolidated.html#configsearchlist","text":"A prioritized list of ConfigLocation entries defining where the library should look for configurations.","title":"ConfigSearchList"},{"location":"44_design_consolidated.html#configlocation-configsource","text":"ConfigLocation : Defines where a configuration might be found (Storage + Handle + Scope). ConfigSource : An instantiated ConfigLocation that is associated with a specific ConfigLayer . It confirms the configuration exists and is readable.","title":"ConfigLocation &amp; ConfigSource"},{"location":"44_design_consolidated.html#configstorage","text":"Provides low-level access to data (e.g., FileConfigStorage , WindowsRegistryConfigStorage , EnvVarConfigStorage ).","title":"ConfigStorage"},{"location":"44_design_consolidated.html#configformat","text":"Parses and writes data in specific formats (e.g., Properties , JSON , YAML , TOML , JSON5 , INI ). It is responsible for instantiating ConfigLayer objects.","title":"ConfigFormat"},{"location":"44_design_consolidated.html#configlayer","text":"A concrete instance of configuration data from a ConfigLocation . It maps hierarchical keys (e.g., database/host ) to ConfigEntry objects.","title":"ConfigLayer"},{"location":"44_design_consolidated.html#configentry","text":"A leaf node in the configuration tree, containing the value and metadata (like the source location).","title":"ConfigEntry"},{"location":"44_design_consolidated.html#444-operational-modes","text":"","title":"4.4.4 Operational Modes"},{"location":"44_design_consolidated.html#test_mode","text":"Bypasses standard OS locations. Uses only explicitly provided test paths (via TESTMODE_DIRECTORIES feature) and standard test resources. TESTMODE_DIRECTORIES entries support the SCOPENAME \":\" PATH format. Prevents tests from interfering with or relying on actual user configurations. Security : Employs a two-tier gate system (Global Static Gate + Instance Dynamic Gate). PERMIT_TEST_MODE defaults to true (\"Productive by Default\") but can be locked down per instance.","title":"TEST_MODE"},{"location":"44_design_consolidated.html#additional_directories","text":"ADDITIONAL_RUNTIME_DIRECTORIES and ADDITIONAL_USER_DIRECTORIES allow adding custom search paths at runtime. Support the SCOPENAME \":\" PATH format, allowing paths to be assigned to any scope (not just their default scope). Prepended to the search list of their respective scope, ensuring they take precedence over default locations.","title":"ADDITIONAL_DIRECTORIES"},{"location":"44_design_consolidated.html#service-mode-auto-refresh-monitoring","text":"If enabled, every access re-checks the search list for new or updated configuration files. Recommended to be used with a Cache Layer to mitigate performance overhead. Cache entries should have a configurable TTL (Time-To-Live). Monitoring Support : Configuration supports the subscribeToUpdates(Consumer<ConfigLocation>) mechanism. This is used by the monitor CLI command to provide real-time reporting of changes.","title":"SERVICE-mode (Auto-refresh &amp; Monitoring)"},{"location":"44_design_consolidated.html#4442-self-configuration-security","text":"Self-configuration (see section 2.2.1) automatically applies settings from the classpath. In environments where the classpath might contain untrusted JARs, this feature can be disabled: ConfigFactoryBuilder . create ( \"metabit\" , \"APP\" ) . setFeature ( ConfigFeature . ENABLE_SELF_CONFIGURATION , false ) . build (); Disabling self-configuration ensures that the ConfigFactory starts with only the settings explicitly provided in code, preventing \"configuration injection\" via the classpath.","title":"4.4.4.2 Self-Configuration Security"},{"location":"44_design_consolidated.html#445-reading-and-writing","text":"","title":"4.4.5 Reading and Writing"},{"location":"44_design_consolidated.html#reading","text":"Sequential search from most specific to least specific scope. Value conversion (String to Integer, Boolean, etc.) is handled at the Configuration facade level.","title":"Reading"},{"location":"44_design_consolidated.html#writing","text":"Direct Write : Attempt to write back to the ConfigLocation where the entry was found. Scope-based Write : Specify a scope for the write operation. Write Fallback (Fall-forward) : If writing to the preferred location fails, attempt to write to a more specific scope (e.g., if MACHINE is read-only, write to USER). Write Cache : Optional layer that buffers writes until a flush() is called.","title":"Writing"},{"location":"44_design_consolidated.html#446-security-and-secrets","text":"mConfig provides specialized handling for sensitive data (API keys, passwords, certificates).","title":"4.4.6 Security and Secrets"},{"location":"44_design_consolidated.html#4461-secret-entries","text":"Sensitive data should be handled via SecretValue and SecretConfigEntryLeaf . Values are obfuscated in memory ( char[] or byte[] instead of String where possible). toString() implementation of secret entries is automatically redacted ( [REDACTED] ). ConfigFacadeImpl.getSecret(key) is the preferred API to retrieve a SecretValue .","title":"4.4.6.1 Secret Entries"},{"location":"44_design_consolidated.html#4462-scheme-driven-secrets","text":"A ConfigEntry is treated as a secret if its ConfigEntrySpecification (from a ConfigScheme ) has the SECRET flag set. - ConfigEntryFactory automatically creates a SecretConfigEntryLeaf if the scheme marks the key as a secret. - Intelligent Type Selection : When creating a secret entry, the factory chooses a SecretType (e.g., PLAIN_TEXT vs SYMMETRIC_KEY ) based on the requested ConfigEntryType .","title":"4.4.6.2 Scheme-Driven Secrets"},{"location":"44_design_consolidated.html#4463-external-secrets-providers","text":"External authentication (e.g., towards networked sources like HashiCorp Vault) can be integrated via specialized modules implementing ConfigSecretsProviderInterface . - Secret providers are initialized during the configuration loading phase. - They can receive a ConfigurationPhaseWrapper to access partially loaded configurations for their own initialization (e.g., to read the Vault address from a local file).","title":"4.4.6.3 External Secrets Providers"},{"location":"44_design_consolidated.html#447-format-specifics","text":"","title":"4.4.7 Format Specifics"},{"location":"44_design_consolidated.html#java-properties","text":"Flat key-value pairs. Trims whitespace. Supports multi-line values with \\ .","title":"Java .properties"},{"location":"44_design_consolidated.html#json-json5","text":"Toplevel must be an Object or Array. JSON5 adds support for comments, trailing commas, and unquoted keys.","title":"JSON / JSON5"},{"location":"44_design_consolidated.html#yaml","text":"Supports hierarchical structures. Implementation must ensure secure parsing (avoiding arbitrary command execution).","title":"YAML"},{"location":"44_design_consolidated.html#ini","text":"Section-based ( [section] ). Hierarchical keys can be mapped to sections using / (e.g., [first/second] ).","title":"INI"},{"location":"44_design_consolidated.html#4477-writing-priorities","text":"When writing to a configuration (e.g., via put ), mConfig applies the following priorities within the requested scope(s): Priority 1: Update Existing Entry. The highest-priority writeable layer in the scope that already contains the key is updated. Priority 2: Add to Existing Layer. If the key is new to the scope, it is added to the highest-priority writeable layer already instantiated in that scope. Priority 3: Create New Layer. If no writeable layers exist for the scope, mConfig attempts to create a new one using the prioritized ConfigStorage and ConfigFormat settings. Writes are strictly scope-isolated unless WRITE_FALLBACK_ACROSS_SCOPES is enabled. For multi-scope writes, mConfig iterates from the most specific to the most generic scope, stopping at the first successful write.","title":"4.4.7.7 Writing Priorities"},{"location":"44_design_consolidated.html#448-blobs-binary-data","text":"mConfig supports Binary Large Objects (certs, licenses, keys) in two distinct ways:","title":"4.4.8 BLOBs (Binary Data)"},{"location":"44_design_consolidated.html#4481-hierarchical-blobs-keyed-leaves","text":"In hierarchical formats like JSON and YAML, binary data can exist as a leaf node with a specific key (e.g., server/certificate ). - YAML : Native support via the !!binary tag. - JSON : Supported via Base64 encoding. If a ConfigScheme marks a key as BYTES , the JSON format will automatically decode the Base64 string into a BlobConfigEntryLeaf . - These entries are part of the regular configuration tree and can be accessed via getValueAsBytes() .","title":"4.4.8.1 Hierarchical BLOBs (Keyed Leaves)"},{"location":"44_design_consolidated.html#4482-flat-blobs-opaque-files","text":"Entire files can be treated as a single binary blob using the FileRawBinaryFormat (extension .bin ). - These are opaque and have no internal structure. - The entry is always accessed using the empty string key ( \"\" ). - Requesting any other key from a flat binary layer will return null .","title":"4.4.8.2 Flat BLOBs (Opaque Files)"},{"location":"44_design_consolidated.html#449-crypto-library-interaction","text":"mConfig is designed to work seamlessly with standard Java crypto libraries (JCE) and third-party libraries like BouncyCastle. JCE Integration : SecretValue can store raw bytes of PrivateKey , PublicKey , or SecretKey . Conversion typically involves key.getEncoded() . BouncyCastle : Can be used to process SecretValue contents (e.g., parsing a PEM-encoded certificate stored as a BYTES entry). Test Strategy : Integration tests ( SecretsJCETest , SecretsBCTest ) verify that low-level binary secrets are preserved exactly as they move through the configuration stack.","title":"4.4.9 Crypto Library Interaction"},{"location":"44_design_consolidated.html#4410-configuration-schemes","text":"Configuration Schemes define the contract for a set of configuration entries, specifying keys, types, defaults, and validation rules. See the detailed Configuration Schemes for information on: - Scheme structure and properties - Future-proofing with the MANDATORY block - JSON format variants - Discovery and registration via ConfigSchemeRepository","title":"4.4.10 Configuration Schemes"},{"location":"44_design_consolidated.html#44101-discovery-and-precedence","text":"Schemes are automatically discovered from the classpath (specifically within .config/ directories) if the JARConfigSource is active. Unified Discovery: Discovery is performed across all classpath resources, including both main and test resource directories. Precedence: If multiple scheme files for the same configuration name are discovered, a \"Last-One-Wins\" strategy is applied based on the order returned by the ClassLoader . In typical development environments (Maven/Gradle), this means production resources might overwrite test resources if they appear later in the classpath enumeration. Scope Agnosticism: Unlike configuration data (layers), schemes are not scope-isolated in TEST_MODE . Production schemes are always loaded to ensure a consistent contract.","title":"4.4.10.1 Discovery and Precedence"},{"location":"44_design_consolidated.html#44102-discovery-and-binding-flow-mermaid","text":"The following diagram illustrates how schemes are discovered by storages, registered in the factory, and finally bound to configuration instances. sequenceDiagram participant S as ConfigStorage (e.g. JAR) participant C as ConfigFactoryInstanceContext participant F as ConfigFactory participant L as LayeredConfiguration participant DL as DefaultLayer Note over S, C: Discovery Phase (during Storage.init) S->>C: registerDiscoveredScheme(name, json) Note over C, F: Registration Phase (during Factory.init) F->>C: getDiscoveredSchemes() F->>F: addConfigScheme(name, scheme) Note over F, L: Binding Phase (during factory.getConfig) F->>L: instantiate with matching scheme L->>DL: transferDefaults(scheme)","title":"4.4.10.2 Discovery and Binding Flow (Mermaid)"},{"location":"44_design_consolidated.html#layered-configuration-mermaid","text":"%%{init: {'theme':'neutral'}}%% erDiagram Configuration ||--|| BasicConfiguration : \"facade for\" BasicConfiguration ||--|| LayeredConfiguration : \"implemented by\" LayeredConfiguration ||--o| CacheLayer : \"at top\" LayeredConfiguration ||--o{ ConfigSource : \"stacked in the middle\" LayeredConfiguration ||--|| DefaultLayer : \"at bottom\" LayeredConfiguration ||--o| ConfigScheme : \"bound to\" ConfigScheme ||--|| DefaultLayer : \"populates\" ConfigScheme ||--o{ ConfigEntrySpecification : \"contains\" ConfigEntry }|--o| ConfigEntrySpecification : \"validated by\" ConfigSource }|--|| ConfigScope : \"belongs to\" ConfigSource ||--|| ConfigLocation : \"where to look\" ConfigSource }o--|| ConfigStorage : \"how to access\" ConfigSource }o--|{ ConfigFormat : \"maps paths to entries\"","title":"Layered Configuration (Mermaid)"},{"location":"44_design_consolidated.html#4411-extending-mconfig","text":"","title":"4.4.11 Extending mConfig"},{"location":"44_design_consolidated.html#44111-adding-new-storages","text":"This is intended for library maintainers extending mConfig with new backends (e.g., databases, cloud stores). When implementing a new ConfigStorage : Module Creation : Create mConfigSource<Name> module with ConfigStorageInterface impl. init(ctx) : Populate ctx.getSearchList() with ConfigLocationImpl for scopes/formats/paths. Read Layers : In tryToReadConfigurationLayers , load/parse entries into LayeredConfiguration . Classpath Order : Auto-discovered; control via ConfigFeature.STORAGE_TYPE_PRIORITIES . Testing : Add unit/integration tests; verify with full mvn clean test . Examples: FileConfigStorage , JARConfigSource , WindowsRegistryConfigSource . In case a specific config format is to be supported as well, it can go into the same module.","title":"4.4.11.1 Adding New Storages"},{"location":"44_design_consolidated.html#44112-adding-new-configfeatures","text":"This is not for library consumers; only project owners should need to perform this step. When adding a new constant to the ConfigFeature enum in mConfigCore , you MUST perform the following steps to ensure technical consistency and avoid runtime errors: Enum Constant : Add the new constant to the ConfigFeature enum. Type Initialization : In the static initialization block of ConfigFeature , you MUST assign a ValueType to the valueType field of the new constant. Example: REGISTRY_BASE_PATH.valueType = ValueType.STRING; Default Values (Optional) : If the feature should have a default value, assign it to the defaultValue field in the same static block. Example: MY_FEATURE.defaultValue = Boolean.TRUE; Verification : Run the ConfigFeatureTypesTest unit test to ensure that all features have a valid type assigned. A missing type will cause a NullPointerException when the feature is accessed via ConfigFactorySettings .","title":"4.4.11.2 Adding New ConfigFeatures"},{"location":"44_design_consolidated.html#4412-best-practices","text":"","title":"4.4.12 Best Practices"},{"location":"44_design_consolidated.html#classpath-layout","text":"Production Defaults : src/main/resources/.config/&lt;company&gt;/&lt;app&gt;/&lt;config&gt;.&lt;ext&gt; (JARConfigSource). Test Mode : src/test/resources/.config/&lt;company&gt;/&lt;app&gt;/ + config/{SCOPE} (overrides project). Schemes : Same path + .scheme.json .","title":"Classpath Layout"},{"location":"44_design_consolidated.html#logging","text":"Implement ConfigLoggingInterface for structured logs (SLF4J/JUL/Logback). Avoid : System.out.println (blocks UI/threads). Secrets auto-redacted.","title":"Logging"},{"location":"44_design_consolidated.html#secrets-handling","text":"Retrieve: SecretValue sv = config.getSecret(key) (scheme-marked SECRET). Use: byte[] data = sv.getValue() ; sv.erase() post-use (secure wipe). Storage: Formats preserve SecretValue ; logs masked. See Handling Secrets .","title":"Secrets Handling"},{"location":"45_ai_guidance.html","text":"4.5 AI Guidance (Notes for Code-Generating Tools) \u00b6 We just know people will use code generators. So it's probably for the best to give the AI some hints. This document summarizes mConfig behaviours that code generators often miss. The goal is to prevent boilerplate, duplicate logic, or incorrect assumptions. Logging and runtime debug control \u00b6 Runtime logging overrides are provided by mConfigSourceEnvVar and are only enabled if ALLOW_MCONFIG_RUNTIME_SETTINGS is set to true . Environment variables start with MCONFIG_RUNTIME_ : MCONFIG_RUNTIME_DEBUG_LEVEL = off|0, error|1, warn|2, info|3, debug|4, trace|5 MCONFIG_RUNTIME_DEBUG_OUTPUT = \"stderr\", \"stdout\", \"quiet\", or file:<path> (appended if present, created if missing) MCONFIG_RUNTIME_DEBUG_OUTPUT is handled internally by InternalLogger . You do not need to implement a custom logger for this. Related docs: - mConfigSourceEnvVar README - logging Console logging for dev/tests \u00b6 ConsoleLogging in mConfigCore main jar (service \"console\" ). Production logging should use mConfigLoggingSlf4j or the default NullLogging . Enable with ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB = \"console\" . Related docs: - logging Defaults belong in resources, not in code \u00b6 mConfigSourceJAR automatically loads defaults from resources located at .config/<company>/<app>/<config>.<ext> . For a standard Maven layout, the default location is: src/main/resources/.config/<company>/<app>/<config>.properties Schemes (typed defaults and validation) live next to the config file: src/main/resources/.config/<company>/<app>/<config>.scheme.json Avoid manual loading of Properties defaults. mConfig already layers JAR defaults with filesystem, environment, and other sources. Avoid null checks. mConfig has ConfigFeature flags to control behaviour, whether to throw an exception or return a default value. Prefer setting defaults as described above. Related docs: - simple configuration loading - 3.8 code improvements - regular use Fallbacks and conversion are built in \u00b6 Fallback across scopes is a first-class feature: FALLBACKS_ACROSS_SCOPES controls reads (default: true) WRITE_FALLBACK_ACROSS_SCOPES controls writes (default: false) Typed getters ( getInteger , getBoolean , etc.) perform conversion for you. Do not parse values manually. To return scheme defaults on missing entries, use: EXCEPTION_ON_MISSING_ENTRY=false DEFAULT_ON_MISSING_ENTRY=true Related docs: - 2.5 config features - design consolidated - 3.8 code improvements converters and mappers \u00b6 ConfigMapper is provided to map from and to POJOs. ConfigUtil.fromProperties(...) is a bridge to convert legacy Properties . ConfigUtil.withOverrides(...) is a bridge to merge custom maps. ConfigUtil.remapped(...) is a bridge to prefix sub-configs. See examples/configuration_views.md for more. Overrides: use scopes, not ad-hoc logic \u00b6 For in-process overrides, prefer ConfigScope.RUNTIME via put(...) . It is the highest regular scope and overrides everything except POLICY . For environment/session overrides, use ConfigScope.SESSION (env vars and CLI). Avoid custom precedence logic. Related docs: - regular use - 2.1 how it works Test Mode is a first-class feature \u00b6 Enable with ConfigFactoryBuilder.setTestMode(true) or via MCONFIG_RUNTIME_TEST_MODE=true when ALLOW_MCONFIG_RUNTIME_SETTINGS is on. Test Mode bypasses OS paths and prefers test resources such as src/test/resources/.config/<company>/<app>/ and src/test/resources/config/{SCOPE} . Test Mode can be locked down globally with ConfigFactoryBuilder.forbidTestMode() . Related docs: - test mode - testing configuration Prefer mConfigUtil adapters for legacy interop \u00b6 ConfigUtil.withOverrides(...) : immutable overlay; prefer over custom map merges. ConfigUtil.remapped(...) : prefix remapping for sub-config views. ConfigUtil.fromProperties(...) : bridge legacy Properties without re-parsing. Related docs: - configuration views - mConfigUtil/src/main/java/org/metabit/platform/support/config/util/ConfigUtil.java","title":"4.5 AI Guidance"},{"location":"45_ai_guidance.html#45-ai-guidance-notes-for-code-generating-tools","text":"We just know people will use code generators. So it's probably for the best to give the AI some hints. This document summarizes mConfig behaviours that code generators often miss. The goal is to prevent boilerplate, duplicate logic, or incorrect assumptions.","title":"4.5 AI Guidance (Notes for Code-Generating Tools)"},{"location":"45_ai_guidance.html#logging-and-runtime-debug-control","text":"Runtime logging overrides are provided by mConfigSourceEnvVar and are only enabled if ALLOW_MCONFIG_RUNTIME_SETTINGS is set to true . Environment variables start with MCONFIG_RUNTIME_ : MCONFIG_RUNTIME_DEBUG_LEVEL = off|0, error|1, warn|2, info|3, debug|4, trace|5 MCONFIG_RUNTIME_DEBUG_OUTPUT = \"stderr\", \"stdout\", \"quiet\", or file:<path> (appended if present, created if missing) MCONFIG_RUNTIME_DEBUG_OUTPUT is handled internally by InternalLogger . You do not need to implement a custom logger for this. Related docs: - mConfigSourceEnvVar README - logging","title":"Logging and runtime debug control"},{"location":"45_ai_guidance.html#console-logging-for-devtests","text":"ConsoleLogging in mConfigCore main jar (service \"console\" ). Production logging should use mConfigLoggingSlf4j or the default NullLogging . Enable with ConfigFeature.LOGGING_TO_USE_IN_CONFIGLIB = \"console\" . Related docs: - logging","title":"Console logging for dev/tests"},{"location":"45_ai_guidance.html#defaults-belong-in-resources-not-in-code","text":"mConfigSourceJAR automatically loads defaults from resources located at .config/<company>/<app>/<config>.<ext> . For a standard Maven layout, the default location is: src/main/resources/.config/<company>/<app>/<config>.properties Schemes (typed defaults and validation) live next to the config file: src/main/resources/.config/<company>/<app>/<config>.scheme.json Avoid manual loading of Properties defaults. mConfig already layers JAR defaults with filesystem, environment, and other sources. Avoid null checks. mConfig has ConfigFeature flags to control behaviour, whether to throw an exception or return a default value. Prefer setting defaults as described above. Related docs: - simple configuration loading - 3.8 code improvements - regular use","title":"Defaults belong in resources, not in code"},{"location":"45_ai_guidance.html#fallbacks-and-conversion-are-built-in","text":"Fallback across scopes is a first-class feature: FALLBACKS_ACROSS_SCOPES controls reads (default: true) WRITE_FALLBACK_ACROSS_SCOPES controls writes (default: false) Typed getters ( getInteger , getBoolean , etc.) perform conversion for you. Do not parse values manually. To return scheme defaults on missing entries, use: EXCEPTION_ON_MISSING_ENTRY=false DEFAULT_ON_MISSING_ENTRY=true Related docs: - 2.5 config features - design consolidated - 3.8 code improvements","title":"Fallbacks and conversion are built in"},{"location":"45_ai_guidance.html#converters-and-mappers","text":"ConfigMapper is provided to map from and to POJOs. ConfigUtil.fromProperties(...) is a bridge to convert legacy Properties . ConfigUtil.withOverrides(...) is a bridge to merge custom maps. ConfigUtil.remapped(...) is a bridge to prefix sub-configs. See examples/configuration_views.md for more.","title":"converters and mappers"},{"location":"45_ai_guidance.html#overrides-use-scopes-not-ad-hoc-logic","text":"For in-process overrides, prefer ConfigScope.RUNTIME via put(...) . It is the highest regular scope and overrides everything except POLICY . For environment/session overrides, use ConfigScope.SESSION (env vars and CLI). Avoid custom precedence logic. Related docs: - regular use - 2.1 how it works","title":"Overrides: use scopes, not ad-hoc logic"},{"location":"45_ai_guidance.html#test-mode-is-a-first-class-feature","text":"Enable with ConfigFactoryBuilder.setTestMode(true) or via MCONFIG_RUNTIME_TEST_MODE=true when ALLOW_MCONFIG_RUNTIME_SETTINGS is on. Test Mode bypasses OS paths and prefers test resources such as src/test/resources/.config/<company>/<app>/ and src/test/resources/config/{SCOPE} . Test Mode can be locked down globally with ConfigFactoryBuilder.forbidTestMode() . Related docs: - test mode - testing configuration","title":"Test Mode is a first-class feature"},{"location":"45_ai_guidance.html#prefer-mconfigutil-adapters-for-legacy-interop","text":"ConfigUtil.withOverrides(...) : immutable overlay; prefer over custom map merges. ConfigUtil.remapped(...) : prefix remapping for sub-config views. ConfigUtil.fromProperties(...) : bridge legacy Properties without re-parsing. Related docs: - configuration views - mConfigUtil/src/main/java/org/metabit/platform/support/config/util/ConfigUtil.java","title":"Prefer mConfigUtil adapters for legacy interop"},{"location":"46_versions.html","text":"4.6 Versions \u00b6 0.8.5 comprehensive documentation overhaul and restructuring full comment preservation for TOML, INI, and (partial) YAML; separate TOML module write support via ConfigCursor updated examples and starters 0.8.0 public relase on github and maven central formats: .properties, .json, .yaml, .toml, .ini sources: JAR, filesystem, environment variables, ZooKeeper, Windows registry dynamic configuration updates, config schemes, input validation, secrets, packaged in multiple modules, mConfigStandard and mConfigFull as POM collections. .deb generated in mConfigTools, in addition to .jar. user-requested code smell pattern finds its place in mConfigCheese. 0.5.3 public release layered configurations, .properties format, raw files, OS-specific defaults, config scheme basics. packaged as a single JAR. JPMS support. 0.4.2 first public release, 2018-03-29 released on macven central and metabit repository + website","title":"4.6 Versions"},{"location":"46_versions.html#46-versions","text":"0.8.5 comprehensive documentation overhaul and restructuring full comment preservation for TOML, INI, and (partial) YAML; separate TOML module write support via ConfigCursor updated examples and starters 0.8.0 public relase on github and maven central formats: .properties, .json, .yaml, .toml, .ini sources: JAR, filesystem, environment variables, ZooKeeper, Windows registry dynamic configuration updates, config schemes, input validation, secrets, packaged in multiple modules, mConfigStandard and mConfigFull as POM collections. .deb generated in mConfigTools, in addition to .jar. user-requested code smell pattern finds its place in mConfigCheese. 0.5.3 public release layered configurations, .properties format, raw files, OS-specific defaults, config scheme basics. packaged as a single JAR. JPMS support. 0.4.2 first public release, 2018-03-29 released on macven central and metabit repository + website","title":"4.6 Versions"},{"location":"47_contributing.html","text":"4.7 Contributing \u00b6 Feature requests and bug reports are welcome. Please use the github issue tracker for now. Pull requests are possible, but please discuss your changes first, follow the code style of the project, and keep the current LICENSE in mind.","title":"4.7 Contributing"},{"location":"47_contributing.html#47-contributing","text":"Feature requests and bug reports are welcome. Please use the github issue tracker for now. Pull requests are possible, but please discuss your changes first, follow the code style of the project, and keep the current LICENSE in mind.","title":"4.7 Contributing"},{"location":"48_legal.html","text":"4.8 Legal \u00b6 The mConfig libraries are provided for use free of charge, including free of charge use in commercial environments. Until the architecture is finalized, metabit reserves the right to change API and contents, and will not allow forks of the source, yet. As of 2026, the mConfig libraries are licensed under Polyform Shield License. See LICENSE file for details.","title":"4.8 Legal"},{"location":"48_legal.html#48-legal","text":"The mConfig libraries are provided for use free of charge, including free of charge use in commercial environments. Until the architecture is finalized, metabit reserves the right to change API and contents, and will not allow forks of the source, yet. As of 2026, the mConfig libraries are licensed under Polyform Shield License. See LICENSE file for details.","title":"4.8 Legal"},{"location":"49_links.html","text":"4.9 Links \u00b6 4.9.1 Requirements and Dependencies \u00b6 mConfig in its Java incarnation requires the Java JRE, version 8 or higher. Additional dependencies are introduced only by its optional modules. mConfigLoggingSlf4j depends on slf4j-api from the org.slf4j package, see slf4j.org 4.9.2 References \u00b6 mConfig is an original work by metabit, J.Wilkes. Platform specific information was gathered from these sources: Linux Windows MacOS Android ...","title":"4.9 Links"},{"location":"49_links.html#49-links","text":"","title":"4.9 Links"},{"location":"49_links.html#491-requirements-and-dependencies","text":"mConfig in its Java incarnation requires the Java JRE, version 8 or higher. Additional dependencies are introduced only by its optional modules. mConfigLoggingSlf4j depends on slf4j-api from the org.slf4j package, see slf4j.org","title":"4.9.1 Requirements and Dependencies"},{"location":"49_links.html#492-references","text":"mConfig is an original work by metabit, J.Wilkes. Platform specific information was gathered from these sources: Linux Windows MacOS Android ...","title":"4.9.2 References"},{"location":"snippets.html","text":"Snippets: Quick Solutions to Common Config Problems \u00b6 mConfig shines for everyday config pains. Copy-paste these snippets\u2014no setup hassles. Each solves a general problem using mConfig's magic (OS paths, layers, reloads, schemes). Starters for full projects \u2022 FAQ for fixes \u2022 CLI 1. Replace Hardcoded Strings/Ports (Zero Magic Strings) \u00b6 Problem: Ports, hosts scattered in code\u2014hard to change/deploy. Config cfg = ConfigUtil . quickConfig ( \"myco\" , \"myapp\" , \"network\" ); String peer = cfg . getString ( \"peer\" ); // localhost int port = cfg . getInteger ( \"port\" ); // 8080 double prob = cfg . getDouble ( \"probability\" ); // 0.5 Place: ~/.config/myco/myapp/network.properties (auto-discovered). Why mConfig? Searches OS standards (XDG, AppData), formats (properties/YAML/JSON), reloads live. Getting Started 2. Env Vars \u2192 Structured Config (No Manual Parsing) \u00b6 Problem: process.env mess; want hierarchical config. Add dep: mConfigSourceEnvVar Env vars: myapp_network_peer=localhost myapp_network_port=8080 try ( ConfigFactory f = ConfigFactoryBuilder . create ( \"myco\" , \"myapp\" ). build ()) { String peer = f . getConfig ( \"network\" ). getString ( \"peer\" ); // SESSION override } Why? <app>_<config>_<key> convention; layers over files. mConfigSourceEnvVar 3. Type-Safe Config with Defaults/Validation \u00b6 Problem: Runtime NumberFormatException ; scattered defaults. src/main/resources/.config/myco/myapp/network.scheme.json : [{ \"name\" : \"port\" , \"type\" : \"int\" , \"default\" : 8080 , \"min\" : 1 , \"max\" : 65535 }] ConfigScheme scheme = ConfigScheme . fromClasspath ( \"network.scheme.json\" ); Config cfg = factory . getConfig ( \"network\" , scheme ); int port = cfg . getInteger ( \"port\" ); // Validates! Why? Centralized scheme\u2014no call-site defaults. Configuration Schemes 4. Hot-Reload on File Changes \u00b6 Problem: Restart for config tweaks? No thanks. Config cfg = factory . getConfig ( \"network\" ); // Watches files // Edit network.properties \u2192 cfg.getInteger(\"port\") updates instantly Why? Built-in watcher; no polling/Spring @Refresh. Priorities 5. Discover Available Configs (No Guesswork) \u00b6 Problem: \"Where's my config?\" factory . listAvailableConfigurations (). forEach ( cdi -> System . out . println ( cdi . getConfigName () + \" @ \" + cdi . getUri ()) ); Why? Traces sources/scopes; CLI equiv: mconfig myco:myapp list 6. Secrets Without Log Leaks \u00b6 Problem: Passwords in logs/heap. In scheme: \"type\":\"secret\" SecretValue pw = ( SecretValue ) cfg . getEntry ( \"db.password\" ); // Masked: ******** String clear = pw . clearValue (); // JIT decrypt/use mConfigSecrets 7. JPMS-Compatible (No IllegalAccessError) \u00b6 module-info.java : module com . example { requires metabit . mconfig . core ; requires metabit . mconfig . util ; } Deps: mConfigStandard (BOM) or mConfigBase . JPMS FAQ 8. Tests: Isolated Configs \u00b6 ConfigFactoryBuilder . setTestMode ( true ); ConfigFactoryBuilder . setTestConfigPaths ( ConfigScope . USER , List . of ( \"src/test/resources\" )); Config cfg = ConfigFactoryBuilder . create ( \"myco\" , \"myapp\" ). build (). getConfig ( \"network\" ); src/test/resources/.config/myco/myapp/network.properties Test Mode Pro Tip: Enable logging ( mConfigLoggingSlf4j + DEBUG) for traces. Full Docs","title":"Snippets: Quick Solutions to Common Config Problems"},{"location":"snippets.html#snippets-quick-solutions-to-common-config-problems","text":"mConfig shines for everyday config pains. Copy-paste these snippets\u2014no setup hassles. Each solves a general problem using mConfig's magic (OS paths, layers, reloads, schemes). Starters for full projects \u2022 FAQ for fixes \u2022 CLI","title":"Snippets: Quick Solutions to Common Config Problems"},{"location":"snippets.html#1-replace-hardcoded-stringsports-zero-magic-strings","text":"Problem: Ports, hosts scattered in code\u2014hard to change/deploy. Config cfg = ConfigUtil . quickConfig ( \"myco\" , \"myapp\" , \"network\" ); String peer = cfg . getString ( \"peer\" ); // localhost int port = cfg . getInteger ( \"port\" ); // 8080 double prob = cfg . getDouble ( \"probability\" ); // 0.5 Place: ~/.config/myco/myapp/network.properties (auto-discovered). Why mConfig? Searches OS standards (XDG, AppData), formats (properties/YAML/JSON), reloads live. Getting Started","title":"1. Replace Hardcoded Strings/Ports (Zero Magic Strings)"},{"location":"snippets.html#2-env-vars-structured-config-no-manual-parsing","text":"Problem: process.env mess; want hierarchical config. Add dep: mConfigSourceEnvVar Env vars: myapp_network_peer=localhost myapp_network_port=8080 try ( ConfigFactory f = ConfigFactoryBuilder . create ( \"myco\" , \"myapp\" ). build ()) { String peer = f . getConfig ( \"network\" ). getString ( \"peer\" ); // SESSION override } Why? <app>_<config>_<key> convention; layers over files. mConfigSourceEnvVar","title":"2. Env Vars \u2192 Structured Config (No Manual Parsing)"},{"location":"snippets.html#3-type-safe-config-with-defaultsvalidation","text":"Problem: Runtime NumberFormatException ; scattered defaults. src/main/resources/.config/myco/myapp/network.scheme.json : [{ \"name\" : \"port\" , \"type\" : \"int\" , \"default\" : 8080 , \"min\" : 1 , \"max\" : 65535 }] ConfigScheme scheme = ConfigScheme . fromClasspath ( \"network.scheme.json\" ); Config cfg = factory . getConfig ( \"network\" , scheme ); int port = cfg . getInteger ( \"port\" ); // Validates! Why? Centralized scheme\u2014no call-site defaults. Configuration Schemes","title":"3. Type-Safe Config with Defaults/Validation"},{"location":"snippets.html#4-hot-reload-on-file-changes","text":"Problem: Restart for config tweaks? No thanks. Config cfg = factory . getConfig ( \"network\" ); // Watches files // Edit network.properties \u2192 cfg.getInteger(\"port\") updates instantly Why? Built-in watcher; no polling/Spring @Refresh. Priorities","title":"4. Hot-Reload on File Changes"},{"location":"snippets.html#5-discover-available-configs-no-guesswork","text":"Problem: \"Where's my config?\" factory . listAvailableConfigurations (). forEach ( cdi -> System . out . println ( cdi . getConfigName () + \" @ \" + cdi . getUri ()) ); Why? Traces sources/scopes; CLI equiv: mconfig myco:myapp list","title":"5. Discover Available Configs (No Guesswork)"},{"location":"snippets.html#6-secrets-without-log-leaks","text":"Problem: Passwords in logs/heap. In scheme: \"type\":\"secret\" SecretValue pw = ( SecretValue ) cfg . getEntry ( \"db.password\" ); // Masked: ******** String clear = pw . clearValue (); // JIT decrypt/use mConfigSecrets","title":"6. Secrets Without Log Leaks"},{"location":"snippets.html#7-jpms-compatible-no-illegalaccesserror","text":"module-info.java : module com . example { requires metabit . mconfig . core ; requires metabit . mconfig . util ; } Deps: mConfigStandard (BOM) or mConfigBase . JPMS FAQ","title":"7. JPMS-Compatible (No IllegalAccessError)"},{"location":"snippets.html#8-tests-isolated-configs","text":"ConfigFactoryBuilder . setTestMode ( true ); ConfigFactoryBuilder . setTestConfigPaths ( ConfigScope . USER , List . of ( \"src/test/resources\" )); Config cfg = ConfigFactoryBuilder . create ( \"myco\" , \"myapp\" ). build (). getConfig ( \"network\" ); src/test/resources/.config/myco/myapp/network.properties Test Mode Pro Tip: Enable logging ( mConfigLoggingSlf4j + DEBUG) for traces. Full Docs","title":"8. Tests: Isolated Configs"},{"location":"examples/index.html","text":"mConfig Examples \u00b6 getting started \u00b6 First, include the following dependency in your project: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}' Next, in your code, instantiate a Configuration object/handle. The shortcut is something like Configuration cfg = ConfigUtil.quickConfig(\"ACME\", \"ourApp\", \"itsConfig\") but the proper, recommended way is to go like this: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ). build ()) { Configuration cfg = factory . getConfiguration ( \"itsConfig\" ); // ... use cfg ... } This way, you can set features for the factory, and get different configurations for different purposes. Supplying your company name (in this example, \"ACME\") and application name (\"ourApp\") is expected minimum. These two are used across OS to differentiate between different applications, and avoid conflicts. You must supply the application name, it is mandatory. If you choose to omit the company name, that may work, but it's not guaranteed - or recommended. (Company name may also be organization, vendor, or anything similar. We call it \"company\" to be consistent with OS conventions.) From the Configuation , you then get the values you need. It's as simple as this: String myString = cfg . getString ( \"theStringKey\" ); Integer myInt = cfg . getString ( \"theIntKey\" ); byte [] myBinary = cfg . getBytes ( \"theBinaryKey\" ); List < String > myList = cfg . getStringList ( \"theListKey\" ); So, where do I put my configuration files? Before we get into the topic of Scopes, a quick answer: that depends on your OS; and ConfigUtil.printConfigPaths(final String companyName, final String applicationName) will print you to stdout all the paths where you can find them in your OS. In a regular maven project, you can put the defaults in src/main/resources/.config/ and src/test/resources/.config/ for development and testing respectively. For above example ACME.ourApp.itsConfig would be in src/main/resources/.config/ACME/ourApp/itsConfig.properties . Also, it doesn't have to be files, but we get to that later. Scopes and Overrides \u00b6 Some config entries are for the installed application, some are for the current user. Some are for the current machine. And some are your defaults. You can change that (as a lot of things), but out of the box, mConfig uses a layered configuration hierarchy: the more specific scopes override the less specific ones . So, the local application configuration overrides the defaults; the user configuration overrides the local application configuration, and so on. This is not \"entire file replacement\", it is granular for each entry. And this is also why you should place your defaults in the resources folder, instead of hardcoding them in your code. But if you want to, you can do that too - there's the \"cheese\" module for that. The mConfigStandard module is a sensible minimum to get you started. The mConfigFull module has everything (stable), and in between, your choice. mConfig is not a framework , it is a modular library. You pick and choose what you need. See the mConfig Modules page for more details. Specific Examples \u00b6 Simple Configuration Loading Testing Configurations Immutable Configuration Views Configuration Scheme Examples Advanced Configuration Handling Integration with CI/CD Crypto Keys and Certificates ZooKeeper Configuration Source","title":"Overview"},{"location":"examples/index.html#mconfig-examples","text":"","title":"mConfig Examples"},{"location":"examples/index.html#getting-started","text":"First, include the following dependency in your project: Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> </dependency> Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}' Next, in your code, instantiate a Configuration object/handle. The shortcut is something like Configuration cfg = ConfigUtil.quickConfig(\"ACME\", \"ourApp\", \"itsConfig\") but the proper, recommended way is to go like this: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ). build ()) { Configuration cfg = factory . getConfiguration ( \"itsConfig\" ); // ... use cfg ... } This way, you can set features for the factory, and get different configurations for different purposes. Supplying your company name (in this example, \"ACME\") and application name (\"ourApp\") is expected minimum. These two are used across OS to differentiate between different applications, and avoid conflicts. You must supply the application name, it is mandatory. If you choose to omit the company name, that may work, but it's not guaranteed - or recommended. (Company name may also be organization, vendor, or anything similar. We call it \"company\" to be consistent with OS conventions.) From the Configuation , you then get the values you need. It's as simple as this: String myString = cfg . getString ( \"theStringKey\" ); Integer myInt = cfg . getString ( \"theIntKey\" ); byte [] myBinary = cfg . getBytes ( \"theBinaryKey\" ); List < String > myList = cfg . getStringList ( \"theListKey\" ); So, where do I put my configuration files? Before we get into the topic of Scopes, a quick answer: that depends on your OS; and ConfigUtil.printConfigPaths(final String companyName, final String applicationName) will print you to stdout all the paths where you can find them in your OS. In a regular maven project, you can put the defaults in src/main/resources/.config/ and src/test/resources/.config/ for development and testing respectively. For above example ACME.ourApp.itsConfig would be in src/main/resources/.config/ACME/ourApp/itsConfig.properties . Also, it doesn't have to be files, but we get to that later.","title":"getting started"},{"location":"examples/index.html#scopes-and-overrides","text":"Some config entries are for the installed application, some are for the current user. Some are for the current machine. And some are your defaults. You can change that (as a lot of things), but out of the box, mConfig uses a layered configuration hierarchy: the more specific scopes override the less specific ones . So, the local application configuration overrides the defaults; the user configuration overrides the local application configuration, and so on. This is not \"entire file replacement\", it is granular for each entry. And this is also why you should place your defaults in the resources folder, instead of hardcoding them in your code. But if you want to, you can do that too - there's the \"cheese\" module for that. The mConfigStandard module is a sensible minimum to get you started. The mConfigFull module has everything (stable), and in between, your choice. mConfig is not a framework , it is a modular library. You pick and choose what you need. See the mConfig Modules page for more details.","title":"Scopes and Overrides"},{"location":"examples/index.html#specific-examples","text":"Simple Configuration Loading Testing Configurations Immutable Configuration Views Configuration Scheme Examples Advanced Configuration Handling Integration with CI/CD Crypto Keys and Certificates ZooKeeper Configuration Source","title":"Specific Examples"},{"location":"examples/advanced_configuration_handling.html","text":"Advanced Configuration Handling \u00b6 This page collects higher-level patterns for controlling how mConfig resolves, validates, and writes configuration data. 1. Write with scope control \u00b6 Writes are scoped and follow a \"least surprise\" policy: Configuration cfg = factory . getConfiguration ( \"network\" ); cfg . put ( \"server/port\" , 8081 , ConfigScope . USER ); 2. Control file format order \u00b6 Reading and writing can use different format orders: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" , \"properties\" )) . setFeature ( ConfigFeature . FILE_FORMAT_WRITING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" )); 3. Use strict schemes \u00b6 To reject unknown keys, turn on strict mode: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . SCHEME_STRICT_MODE , true ); 4. Missing values behavior \u00b6 If you want scheme defaults instead of exceptions: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . EXCEPTION_ON_MISSING_ENTRY , false ) . setFeature ( ConfigFeature . DEFAULT_ON_MISSING_ENTRY , true ); 5. Subscribe to updates \u00b6 React when values change at runtime: Configuration cfg = factory . getConfiguration ( \"network\" ); cfg . subscribeToUpdates ( location -> { System . out . println ( \"Config changed in scope: \" + location . getScope ()); }); NB: The changes are automatically propagated to the mConfig Configurations anyhow. If you take the values from the Configurations directly, they will be up-to-date. Above subscription is to support triggering actions when the configuration changes, e.g. thread restarts. 6. Control scope fallbacks \u00b6 By default, mConfig falls back to less specific scopes when a value is missing. You can change that: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FALLBACKS_ACROSS_SCOPES , false ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // Only the requested scope (plus PRODUCT defaults) is considered. } 7. Prioritize storage types \u00b6 If multiple storage backends are available, change their priority within a scope: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"registry\" , \"JAR\" )) . build ()) { // Files override registry, registry overrides JAR defaults. } 8. Use secrets providers \u00b6 If you have secrets in schemes, add a secrets provider to resolve them: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . SECRETS_PROVIDER_ID , \"my-secrets\" ) . setSecretsProviderConfig ( Map . of ( \"endpoint\" , \"https://vault.example\" )); Related docs: - Config Features - Priorities and Hierarchies - Writing Configurations","title":"Advanced Configuration Handling"},{"location":"examples/advanced_configuration_handling.html#advanced-configuration-handling","text":"This page collects higher-level patterns for controlling how mConfig resolves, validates, and writes configuration data.","title":"Advanced Configuration Handling"},{"location":"examples/advanced_configuration_handling.html#1-write-with-scope-control","text":"Writes are scoped and follow a \"least surprise\" policy: Configuration cfg = factory . getConfiguration ( \"network\" ); cfg . put ( \"server/port\" , 8081 , ConfigScope . USER );","title":"1. Write with scope control"},{"location":"examples/advanced_configuration_handling.html#2-control-file-format-order","text":"Reading and writing can use different format orders: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" , \"properties\" )) . setFeature ( ConfigFeature . FILE_FORMAT_WRITING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" ));","title":"2. Control file format order"},{"location":"examples/advanced_configuration_handling.html#3-use-strict-schemes","text":"To reject unknown keys, turn on strict mode: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . SCHEME_STRICT_MODE , true );","title":"3. Use strict schemes"},{"location":"examples/advanced_configuration_handling.html#4-missing-values-behavior","text":"If you want scheme defaults instead of exceptions: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . EXCEPTION_ON_MISSING_ENTRY , false ) . setFeature ( ConfigFeature . DEFAULT_ON_MISSING_ENTRY , true );","title":"4. Missing values behavior"},{"location":"examples/advanced_configuration_handling.html#5-subscribe-to-updates","text":"React when values change at runtime: Configuration cfg = factory . getConfiguration ( \"network\" ); cfg . subscribeToUpdates ( location -> { System . out . println ( \"Config changed in scope: \" + location . getScope ()); }); NB: The changes are automatically propagated to the mConfig Configurations anyhow. If you take the values from the Configurations directly, they will be up-to-date. Above subscription is to support triggering actions when the configuration changes, e.g. thread restarts.","title":"5. Subscribe to updates"},{"location":"examples/advanced_configuration_handling.html#6-control-scope-fallbacks","text":"By default, mConfig falls back to less specific scopes when a value is missing. You can change that: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FALLBACKS_ACROSS_SCOPES , false ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // Only the requested scope (plus PRODUCT defaults) is considered. }","title":"6. Control scope fallbacks"},{"location":"examples/advanced_configuration_handling.html#7-prioritize-storage-types","text":"If multiple storage backends are available, change their priority within a scope: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"registry\" , \"JAR\" )) . build ()) { // Files override registry, registry overrides JAR defaults. }","title":"7. Prioritize storage types"},{"location":"examples/advanced_configuration_handling.html#8-use-secrets-providers","text":"If you have secrets in schemes, add a secrets provider to resolve them: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . SECRETS_PROVIDER_ID , \"my-secrets\" ) . setSecretsProviderConfig ( Map . of ( \"endpoint\" , \"https://vault.example\" )); Related docs: - Config Features - Priorities and Hierarchies - Writing Configurations","title":"8. Use secrets providers"},{"location":"examples/configuration_views.html","text":"Immutable Configuration Views \u00b6 These utility methods in ConfigUtil create lightweight, immutable Configuration views for overrides, prefix remapping, and Properties adaptation. They support chaining and inherit scheme validation where applicable. withOverrides \u00b6 Overlay in-memory overrides on a parent Configuration : Configuration parent = factory . getConfiguration ( \"app\" ); Map < String , Object > overrides = Map . of ( \"db.host\" , \"localhost\" , \"db.port\" , 5432 ); Configuration cfg = ConfigUtil . withOverrides ( parent , overrides ); String host = cfg . getString ( \"db.host\" ); // \"localhost\" Integer port = cfg . getInteger ( \"db.port\" ); // 5432 (auto-convert) Overrides take precedence. Lazy type conversion (null on parse fail). If parent has ConfigScheme , validates overrides (throws IllegalArgumentException on mismatch). getAllConfigurationKeysFlattened() : union of keys. remapped \u00b6 Remap prefixed keys for sub-config views (e.g., DB modules): Configuration cfg = ConfigUtil . remapped ( parent , \"super_db.\" , \"db.\" ); String host = cfg . getString ( \"db.host\" ); // \u2192 parent.getString(\"super_db.host\") String other = cfg . getString ( \"other.key\" ); // passthru get(\"db.xxx\") \u2192 parent.get(\"super_db.xxx\") . Non-matching keys delegate directly. Trims prefixes/keys aggressively. Uniform for all typed getters; projects getAll* . Inherits scheme. fromProperties \u00b6 Adapt legacy java.util.Properties : Properties props = new Properties (); props . setProperty ( \"key1\" , \"value1\" ); props . setProperty ( \"key2\" , \"42\" ); Configuration cfg = ConfigUtil . fromProperties ( props ); String v1 = cfg . getString ( \"key1\" ); // \"value1\" Integer v2 = cfg . getInteger ( \"key2\" ); // 42 (null on fail) Lazy parsing, null on errors. No scheme. getAllConfigurationKeysFlattened() : props keys. Chaining \u00b6 Combine freely: Configuration dbView = ConfigUtil . withOverrides ( ConfigUtil . remapped ( parent , \"legacy_db.\" , \"db.\" ), Map . of ( \"db.timeout\" , 30 ) ); Views are read-only ( put* throws UnsupportedOperationException ).\"","title":"Configuration Views"},{"location":"examples/configuration_views.html#immutable-configuration-views","text":"These utility methods in ConfigUtil create lightweight, immutable Configuration views for overrides, prefix remapping, and Properties adaptation. They support chaining and inherit scheme validation where applicable.","title":"Immutable Configuration Views"},{"location":"examples/configuration_views.html#withoverrides","text":"Overlay in-memory overrides on a parent Configuration : Configuration parent = factory . getConfiguration ( \"app\" ); Map < String , Object > overrides = Map . of ( \"db.host\" , \"localhost\" , \"db.port\" , 5432 ); Configuration cfg = ConfigUtil . withOverrides ( parent , overrides ); String host = cfg . getString ( \"db.host\" ); // \"localhost\" Integer port = cfg . getInteger ( \"db.port\" ); // 5432 (auto-convert) Overrides take precedence. Lazy type conversion (null on parse fail). If parent has ConfigScheme , validates overrides (throws IllegalArgumentException on mismatch). getAllConfigurationKeysFlattened() : union of keys.","title":"withOverrides"},{"location":"examples/configuration_views.html#remapped","text":"Remap prefixed keys for sub-config views (e.g., DB modules): Configuration cfg = ConfigUtil . remapped ( parent , \"super_db.\" , \"db.\" ); String host = cfg . getString ( \"db.host\" ); // \u2192 parent.getString(\"super_db.host\") String other = cfg . getString ( \"other.key\" ); // passthru get(\"db.xxx\") \u2192 parent.get(\"super_db.xxx\") . Non-matching keys delegate directly. Trims prefixes/keys aggressively. Uniform for all typed getters; projects getAll* . Inherits scheme.","title":"remapped"},{"location":"examples/configuration_views.html#fromproperties","text":"Adapt legacy java.util.Properties : Properties props = new Properties (); props . setProperty ( \"key1\" , \"value1\" ); props . setProperty ( \"key2\" , \"42\" ); Configuration cfg = ConfigUtil . fromProperties ( props ); String v1 = cfg . getString ( \"key1\" ); // \"value1\" Integer v2 = cfg . getInteger ( \"key2\" ); // 42 (null on fail) Lazy parsing, null on errors. No scheme. getAllConfigurationKeysFlattened() : props keys.","title":"fromProperties"},{"location":"examples/configuration_views.html#chaining","text":"Combine freely: Configuration dbView = ConfigUtil . withOverrides ( ConfigUtil . remapped ( parent , \"legacy_db.\" , \"db.\" ), Map . of ( \"db.timeout\" , 30 ) ); Views are read-only ( put* throws UnsupportedOperationException ).\"","title":"Chaining"},{"location":"examples/handling_crypto_keys_and_certificates.html","text":"Handling Cryptographic Keys and Certificates with mConfig \u00b6 mConfig supports storing and retrieving cryptographic material (keys, certificates) securely using SecretValue . Binary data (DER) is stored as BYTES entries marked as SECRET in schemes. PEM can be stored as STRING or BYTES and parsed with BouncyCastle. Note : Sensitive data is redacted in logs. Use SecretValue.erase() after use. 1. Prerequisites \u00b6 JCE : Included in JDK. BouncyCastle (optional, for PEM/EC/FIPS): Add to classpath: Maven: <dependency> <groupId> org.bouncycastle </groupId> <artifactId> bcprov-jdk18on </artifactId> <version> 1.78 </version> </dependency> Gradle: implementation 'org.bouncycastle:bcprov-jdk18on:1.78' Mark scheme entries as SECRET : { \"keys/rsa/private\" : { \"type\" : \"BYTES\" , \"flags\" : [ \"SECRET\" ], \"secretType\" : \"PRIVATE_KEY\" }, \"certs/server\" : { \"type\" : \"BYTES\" , \"flags\" : [ \"SECRET\" ], \"secretType\" : \"CERTIFICATE\" } } 2. Setup ConfigFactory \u00b6 ConfigScheme scheme = ConfigScheme . fromJSON (...) // load scheme ConfigFactory factory = ConfigFactoryBuilder . create ( \"mycompany\" , \"myapp\" ) . setFeature ( ConfigFeature . CONFIG_SCHEME_LIST , Map . of ( \"crypto\" , scheme )) . build (); Configuration config = factory . getConfig ( \"crypto\" ); Instead of specifying the scheme programmatically, you can also place the scheme file in the respective resource directory within the jar/classpath. (separate folders below \"main\" for production, below \"test\" for integration tests.) 3. Generate and Store RSA Keypair (JCE) \u00b6 import java.security.* ; // Generate KeyPairGenerator kpg = KeyPairGenerator . getInstance ( \"RSA\" ); kpg . initialize ( 2048 ); KeyPair kp = kpg . generateKeyPair (); // DER bytes byte [] privDer = kp . getPrivate (). getEncoded (); byte [] pubDer = kp . getPublic (). getEncoded (); // Store as SecretValue (auto-typed if scheme helps) config . put ( \"keys/rsa/private\" , new BasicSecretValue ( privDer , SecretType . PRIVATE_KEY ), ConfigScope . USER ); config . put ( \"keys/rsa/public\" , pubDer , ConfigScope . USER ); // Public OK as non-secret // To HOST scope (elevated privs may be needed) config . put ( \"keys/rsa/private\" , new BasicSecretValue ( privDer , SecretType . PRIVATE_KEY ), ConfigScope . HOST ); 4. Read DER Private Key (JCE) \u00b6 SecretValue privSecret = config . getSecret ( \"keys/rsa/private\" ); if ( privSecret != null ) { byte [] derBytes = privSecret . getValue (); KeyFactory kf = KeyFactory . getInstance ( \"RSA\" ); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( derBytes ); PrivateKey privateKey = kf . generatePrivate ( keySpec ); privSecret . erase (); // Secure wipe } 5. Generate and Store Self-Signed X.509 Certificate (BouncyCastle) \u00b6 import org.bouncycastle.jce.provider.BouncyCastleProvider ; import org.bouncycastle.cert.* ; // etc. // ... Security . addProvider ( new BouncyCastleProvider ()); KeyPairGenerator kpg = KeyPairGenerator . getInstance ( \"RSA\" , \"BC\" ); kpg . initialize ( 2048 ); KeyPair kp = kpg . generateKeyPair (); long now = System . currentTimeMillis (); X500Name issuer = new X500Name ( \"CN=TestCA\" ); BigInteger serial = BigInteger . valueOf ( now ); Date notBefore = new Date ( now - 5000 ); Date notAfter = new Date ( now + 365L * 24 * 3600 * 1000 ); ContentSigner signer = new JcaContentSignerBuilder ( \"SHA256withRSA\" ). setProvider ( \"BC\" ). build ( kp . getPrivate ()); X509v3CertificateBuilder builder = new JcaX509v3CertificateBuilder ( issuer , serial , notBefore , notAfter , issuer , kp . getPublic ()); X509CertificateHolder holder = builder . build ( signer ); X509Certificate cert = new JcaX509CertificateConverter (). setProvider ( \"BC\" ). getCertificate ( holder ); // Store DER byte [] certDer = cert . getEncoded (); config . put ( \"certs/server\" , new BasicSecretValue ( certDer , SecretType . CERTIFICATE ), ConfigScope . USER ); 6. Read X.509 Certificate (JCE) \u00b6 SecretValue certSecret = config . getSecret ( \"certs/server\" ); if ( certSecret != null ) { byte [] derBytes = certSecret . getValue (); CertificateFactory cf = CertificateFactory . getInstance ( \"X.509\" ); X509Certificate cert = ( X509Certificate ) cf . generateCertificate ( new ByteArrayInputStream ( derBytes )); certSecret . erase (); } 7. PEM Handling (BouncyCastle) \u00b6 Generate PEM Private Key \u00b6 import org.bouncycastle.util.io.pem.PemWriter ; import org.bouncycastle.openssl.PEMEncryptedKeyPair ; import org.bouncycastle.openssl.jcajce.JcaPEMWriter ; // Simpler try ( StringWriter sw = new StringWriter (); JcaPEMWriter pemWriter = new JcaPEMWriter ( sw )) { pemWriter . writeObject ( kp . getPrivate ()); String pem = sw . toString (); config . put ( \"keys/rsa/private.pem\" , pem , ConfigScope . USER ); // STRING } Read PEM Private Key \u00b6 String pemStr = ( String ) config . getValue ( \"keys/rsa/private.pem\" ); // or SecretValue if marked try ( PEMParser pemParser = new PEMParser ( new StringReader ( pemStr ))) { Object obj = pemParser . readObject (); if ( obj instanceof PEMKeyPair ) { PEMKeyPair pemPair = ( PEMKeyPair ) obj ; JcaPEMKeyConverter conv = new JcaPEMKeyConverter (). setProvider ( \"BC\" ); PrivateKey privKey = conv . getPrivateKey ( pemPair . getPrivateKeyInfo ()); } } 8. Writing to Specific Scopes/Dirs \u00b6 mConfig writes to OS-standard paths: - USER : ~/.config/<company>/<app>/crypto (JSON/TOML/etc.) - HOST : /etc/<app>/crypto (Linux; admin req'd) Use config.put(key, value, scope) . Tips \u00b6 Use SecretType.PRIVATE_KEY , CERTIFICATE for typing. Tests: integrationtestSecretsBC/JCE verify roundtrip. Prod: Rotate keys via CLI mconfig set --scope USER . See ../44_design_consolidated.md for more.","title":"Handling Crypto Keys and Certificates"},{"location":"examples/handling_crypto_keys_and_certificates.html#handling-cryptographic-keys-and-certificates-with-mconfig","text":"mConfig supports storing and retrieving cryptographic material (keys, certificates) securely using SecretValue . Binary data (DER) is stored as BYTES entries marked as SECRET in schemes. PEM can be stored as STRING or BYTES and parsed with BouncyCastle. Note : Sensitive data is redacted in logs. Use SecretValue.erase() after use.","title":"Handling Cryptographic Keys and Certificates with mConfig"},{"location":"examples/handling_crypto_keys_and_certificates.html#1-prerequisites","text":"JCE : Included in JDK. BouncyCastle (optional, for PEM/EC/FIPS): Add to classpath: Maven: <dependency> <groupId> org.bouncycastle </groupId> <artifactId> bcprov-jdk18on </artifactId> <version> 1.78 </version> </dependency> Gradle: implementation 'org.bouncycastle:bcprov-jdk18on:1.78' Mark scheme entries as SECRET : { \"keys/rsa/private\" : { \"type\" : \"BYTES\" , \"flags\" : [ \"SECRET\" ], \"secretType\" : \"PRIVATE_KEY\" }, \"certs/server\" : { \"type\" : \"BYTES\" , \"flags\" : [ \"SECRET\" ], \"secretType\" : \"CERTIFICATE\" } }","title":"1. Prerequisites"},{"location":"examples/handling_crypto_keys_and_certificates.html#2-setup-configfactory","text":"ConfigScheme scheme = ConfigScheme . fromJSON (...) // load scheme ConfigFactory factory = ConfigFactoryBuilder . create ( \"mycompany\" , \"myapp\" ) . setFeature ( ConfigFeature . CONFIG_SCHEME_LIST , Map . of ( \"crypto\" , scheme )) . build (); Configuration config = factory . getConfig ( \"crypto\" ); Instead of specifying the scheme programmatically, you can also place the scheme file in the respective resource directory within the jar/classpath. (separate folders below \"main\" for production, below \"test\" for integration tests.)","title":"2. Setup ConfigFactory"},{"location":"examples/handling_crypto_keys_and_certificates.html#3-generate-and-store-rsa-keypair-jce","text":"import java.security.* ; // Generate KeyPairGenerator kpg = KeyPairGenerator . getInstance ( \"RSA\" ); kpg . initialize ( 2048 ); KeyPair kp = kpg . generateKeyPair (); // DER bytes byte [] privDer = kp . getPrivate (). getEncoded (); byte [] pubDer = kp . getPublic (). getEncoded (); // Store as SecretValue (auto-typed if scheme helps) config . put ( \"keys/rsa/private\" , new BasicSecretValue ( privDer , SecretType . PRIVATE_KEY ), ConfigScope . USER ); config . put ( \"keys/rsa/public\" , pubDer , ConfigScope . USER ); // Public OK as non-secret // To HOST scope (elevated privs may be needed) config . put ( \"keys/rsa/private\" , new BasicSecretValue ( privDer , SecretType . PRIVATE_KEY ), ConfigScope . HOST );","title":"3. Generate and Store RSA Keypair (JCE)"},{"location":"examples/handling_crypto_keys_and_certificates.html#4-read-der-private-key-jce","text":"SecretValue privSecret = config . getSecret ( \"keys/rsa/private\" ); if ( privSecret != null ) { byte [] derBytes = privSecret . getValue (); KeyFactory kf = KeyFactory . getInstance ( \"RSA\" ); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( derBytes ); PrivateKey privateKey = kf . generatePrivate ( keySpec ); privSecret . erase (); // Secure wipe }","title":"4. Read DER Private Key (JCE)"},{"location":"examples/handling_crypto_keys_and_certificates.html#5-generate-and-store-self-signed-x509-certificate-bouncycastle","text":"import org.bouncycastle.jce.provider.BouncyCastleProvider ; import org.bouncycastle.cert.* ; // etc. // ... Security . addProvider ( new BouncyCastleProvider ()); KeyPairGenerator kpg = KeyPairGenerator . getInstance ( \"RSA\" , \"BC\" ); kpg . initialize ( 2048 ); KeyPair kp = kpg . generateKeyPair (); long now = System . currentTimeMillis (); X500Name issuer = new X500Name ( \"CN=TestCA\" ); BigInteger serial = BigInteger . valueOf ( now ); Date notBefore = new Date ( now - 5000 ); Date notAfter = new Date ( now + 365L * 24 * 3600 * 1000 ); ContentSigner signer = new JcaContentSignerBuilder ( \"SHA256withRSA\" ). setProvider ( \"BC\" ). build ( kp . getPrivate ()); X509v3CertificateBuilder builder = new JcaX509v3CertificateBuilder ( issuer , serial , notBefore , notAfter , issuer , kp . getPublic ()); X509CertificateHolder holder = builder . build ( signer ); X509Certificate cert = new JcaX509CertificateConverter (). setProvider ( \"BC\" ). getCertificate ( holder ); // Store DER byte [] certDer = cert . getEncoded (); config . put ( \"certs/server\" , new BasicSecretValue ( certDer , SecretType . CERTIFICATE ), ConfigScope . USER );","title":"5. Generate and Store Self-Signed X.509 Certificate (BouncyCastle)"},{"location":"examples/handling_crypto_keys_and_certificates.html#6-read-x509-certificate-jce","text":"SecretValue certSecret = config . getSecret ( \"certs/server\" ); if ( certSecret != null ) { byte [] derBytes = certSecret . getValue (); CertificateFactory cf = CertificateFactory . getInstance ( \"X.509\" ); X509Certificate cert = ( X509Certificate ) cf . generateCertificate ( new ByteArrayInputStream ( derBytes )); certSecret . erase (); }","title":"6. Read X.509 Certificate (JCE)"},{"location":"examples/handling_crypto_keys_and_certificates.html#7-pem-handling-bouncycastle","text":"","title":"7. PEM Handling (BouncyCastle)"},{"location":"examples/handling_crypto_keys_and_certificates.html#generate-pem-private-key","text":"import org.bouncycastle.util.io.pem.PemWriter ; import org.bouncycastle.openssl.PEMEncryptedKeyPair ; import org.bouncycastle.openssl.jcajce.JcaPEMWriter ; // Simpler try ( StringWriter sw = new StringWriter (); JcaPEMWriter pemWriter = new JcaPEMWriter ( sw )) { pemWriter . writeObject ( kp . getPrivate ()); String pem = sw . toString (); config . put ( \"keys/rsa/private.pem\" , pem , ConfigScope . USER ); // STRING }","title":"Generate PEM Private Key"},{"location":"examples/handling_crypto_keys_and_certificates.html#read-pem-private-key","text":"String pemStr = ( String ) config . getValue ( \"keys/rsa/private.pem\" ); // or SecretValue if marked try ( PEMParser pemParser = new PEMParser ( new StringReader ( pemStr ))) { Object obj = pemParser . readObject (); if ( obj instanceof PEMKeyPair ) { PEMKeyPair pemPair = ( PEMKeyPair ) obj ; JcaPEMKeyConverter conv = new JcaPEMKeyConverter (). setProvider ( \"BC\" ); PrivateKey privKey = conv . getPrivateKey ( pemPair . getPrivateKeyInfo ()); } }","title":"Read PEM Private Key"},{"location":"examples/handling_crypto_keys_and_certificates.html#8-writing-to-specific-scopesdirs","text":"mConfig writes to OS-standard paths: - USER : ~/.config/<company>/<app>/crypto (JSON/TOML/etc.) - HOST : /etc/<app>/crypto (Linux; admin req'd) Use config.put(key, value, scope) .","title":"8. Writing to Specific Scopes/Dirs"},{"location":"examples/handling_crypto_keys_and_certificates.html#tips","text":"Use SecretType.PRIVATE_KEY , CERTIFICATE for typing. Tests: integrationtestSecretsBC/JCE verify roundtrip. Prod: Rotate keys via CLI mconfig set --scope USER . See ../44_design_consolidated.md for more.","title":"Tips"},{"location":"examples/integration_with_cicd.html","text":"Integration with CI/CD \u00b6 This example shows how to make mConfig predictable in CI/CD and automated pipelines. 1. Enable Test Mode via environment variables \u00b6 mConfig can enable Test Mode without code changes when ALLOW_MCONFIG_RUNTIME_SETTINGS is on. export MCONFIG_RUNTIME_TEST_MODE = true export MCONFIG_RUNTIME_DEBUG_LEVEL = debug In code, allow runtime settings: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . ALLOW_MCONFIG_RUNTIME_SETTINGS , true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); } 2. Keep test configs in test resources \u00b6 CI usually runs tests from the build tree. Keep your test configs here: - src/test/resources/.config/ACME/ourApp/network.properties 3. Prefer configuration schemes in CI \u00b6 Schemes are recommended in CI because they: 1. Prevent most cases of incomplete configs by providing defaults. 2. Enforce mandatory values and validation rules early. Add a scheme in test resources: - src/test/resources/.config/ACME/ourApp/network.scheme.json [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 }, { \"KEY\" : \"server/tls\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ] 4. Use explicit test directories (optional) \u00b6 If your CI environment mounts a special directory, point mConfig at it: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . setFeature ( ConfigFeature . TESTMODE_DIRECTORIES , List . of ( \"USER:/mnt/ci/config/user\" , \"APPLICATION:/mnt/ci/config/app\" )); 5. Pin formats and storage priority (optional) \u00b6 Avoid surprises from environment changes by pinning priorities: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" , \"properties\" )) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"JAR\" )); Related docs: - Test Mode - Configuration Schemes - Config Features","title":"Integration with CI/CD"},{"location":"examples/integration_with_cicd.html#integration-with-cicd","text":"This example shows how to make mConfig predictable in CI/CD and automated pipelines.","title":"Integration with CI/CD"},{"location":"examples/integration_with_cicd.html#1-enable-test-mode-via-environment-variables","text":"mConfig can enable Test Mode without code changes when ALLOW_MCONFIG_RUNTIME_SETTINGS is on. export MCONFIG_RUNTIME_TEST_MODE = true export MCONFIG_RUNTIME_DEBUG_LEVEL = debug In code, allow runtime settings: try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . ALLOW_MCONFIG_RUNTIME_SETTINGS , true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); }","title":"1. Enable Test Mode via environment variables"},{"location":"examples/integration_with_cicd.html#2-keep-test-configs-in-test-resources","text":"CI usually runs tests from the build tree. Keep your test configs here: - src/test/resources/.config/ACME/ourApp/network.properties","title":"2. Keep test configs in test resources"},{"location":"examples/integration_with_cicd.html#3-prefer-configuration-schemes-in-ci","text":"Schemes are recommended in CI because they: 1. Prevent most cases of incomplete configs by providing defaults. 2. Enforce mandatory values and validation rules early. Add a scheme in test resources: - src/test/resources/.config/ACME/ourApp/network.scheme.json [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 }, { \"KEY\" : \"server/tls\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ]","title":"3. Prefer configuration schemes in CI"},{"location":"examples/integration_with_cicd.html#4-use-explicit-test-directories-optional","text":"If your CI environment mounts a special directory, point mConfig at it: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . setFeature ( ConfigFeature . TESTMODE_DIRECTORIES , List . of ( \"USER:/mnt/ci/config/user\" , \"APPLICATION:/mnt/ci/config/app\" ));","title":"4. Use explicit test directories (optional)"},{"location":"examples/integration_with_cicd.html#5-pin-formats-and-storage-priority-optional","text":"Avoid surprises from environment changes by pinning priorities: ConfigFactoryBuilder builder = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setFeature ( ConfigFeature . FILE_FORMAT_READING_PRIORITIES , List . of ( \"TOML\" , \"YAML\" , \"JSON\" , \"properties\" )) . setFeature ( ConfigFeature . STORAGE_TYPE_PRIORITIES , List . of ( \"files\" , \"JAR\" )); Related docs: - Test Mode - Configuration Schemes - Config Features","title":"5. Pin formats and storage priority (optional)"},{"location":"examples/java-modules.html","text":"Java Platform Module System (JPMS) \u00b6 Java 9 introduced the Java Platform Module System (JPMS), often referred to as \"Java Modules\". JPMS adds strong encapsulation and explicit dependencies between modules. mConfig is modular and uses JPMS so you can choose only the parts you need. If your application uses module-info.java , you should explicitly declare the mConfig modules you depend on. Why this matters \u00b6 Stronger encapsulation: internal packages are hidden unless exported. Explicit dependencies: missing requires entries cause compile-time errors. Service loading: mConfig uses the service loader to discover formats and sources. Minimal module-info.java \u00b6 If you only use the core and utility APIs: module my . app { requires metabit . mconfig . core ; requires metabit . mconfig . util ; } Typical setup \u00b6 If you use the standard bundle: module my . app { // ... requires metabit . mconfig . core ; requires metabit . mconfig . scheme ; requires metabit . mconfig . secrets ; requires metabit . mconfig . util ; requires metabit . mconfig . modules . jar ; requires metabit . mconfig . modules . filesystem ; requires metabit . mconfig . format . javaproperties ; // ... } Notes on auto-discovery \u00b6 Most format and source modules are discovered via the service loader. You do not need to requires them directly unless you reference their classes. But they must be on the classpath, and visible to the service loader. Related docs: - Getting Started - mConfig Modules","title":"JPMS (Java Modules)"},{"location":"examples/java-modules.html#java-platform-module-system-jpms","text":"Java 9 introduced the Java Platform Module System (JPMS), often referred to as \"Java Modules\". JPMS adds strong encapsulation and explicit dependencies between modules. mConfig is modular and uses JPMS so you can choose only the parts you need. If your application uses module-info.java , you should explicitly declare the mConfig modules you depend on.","title":"Java Platform Module System (JPMS)"},{"location":"examples/java-modules.html#why-this-matters","text":"Stronger encapsulation: internal packages are hidden unless exported. Explicit dependencies: missing requires entries cause compile-time errors. Service loading: mConfig uses the service loader to discover formats and sources.","title":"Why this matters"},{"location":"examples/java-modules.html#minimal-module-infojava","text":"If you only use the core and utility APIs: module my . app { requires metabit . mconfig . core ; requires metabit . mconfig . util ; }","title":"Minimal module-info.java"},{"location":"examples/java-modules.html#typical-setup","text":"If you use the standard bundle: module my . app { // ... requires metabit . mconfig . core ; requires metabit . mconfig . scheme ; requires metabit . mconfig . secrets ; requires metabit . mconfig . util ; requires metabit . mconfig . modules . jar ; requires metabit . mconfig . modules . filesystem ; requires metabit . mconfig . format . javaproperties ; // ... }","title":"Typical setup"},{"location":"examples/java-modules.html#notes-on-auto-discovery","text":"Most format and source modules are discovered via the service loader. You do not need to requires them directly unless you reference their classes. But they must be on the classpath, and visible to the service loader. Related docs: - Getting Started - mConfig Modules","title":"Notes on auto-discovery"},{"location":"examples/mconfig-modules.html","text":"mConfig Modules \u00b6 mConfig is a modular library with which you can pick and choose the components you need. Choosing Your Modules \u00b6 Start simple : Use mConfigStandard for most applications Need more formats? : Use mConfigFull to get JSON, YAML, and JSON5 support Custom setup : Include only the specific modules you need Reduce if needed : start with 'mConfigCore' and add only what you need All modules share the same version number and are designed to work together seamlessly. Just add the modules you need to your project's dependencies. mConfig will automatically load them at runtime, when they are in the classpath. Java JPMS (since Java 9) considerations: see Java Platform Module System . mConfigStandard Modules \u00b6 The mConfigStandard module provides a sensible minimum configuration to get started quickly. Module Artifact ID Description Core API mConfigCore Core interfaces and base classes File Source mConfigSourceFile configuration from files in standard OS locations System Properties Source mConfigSourceSystemProperties configuration from Java system properties Properties Format mConfigFormatJavaProperties Support for Java .properties file format Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency> Caveat: Do not omit/forget the type being pom . Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}' Additional mConfigFull Modules \u00b6 The mConfigFull module includes everything from mConfigStandard plus additional mature, stable modules: Module Artifact ID Description Environment Variables Source mConfigSourceEnvVar Read configuration from environment variables Windows Registry Source mConfigWinRegistry Read configuration from Windows Registry (Windows only) JSON Format mConfigFormatJSONwithJackson Support for JSON configuration files using Jackson JSON5 Format mConfigFormatJSONwithJackson Support for JSON5 configuration files using Jackson YAML (Jackson) Format mConfigFormatYAMLwithJackson Support for YAML configuration files using Jackson YAML (SnakeYAML) Format mConfigFormatYAMLwithSnakeYAML Support for YAML configuration files using SnakeYAML TOML Format mConfigFormatTOMLwithJackson Support for TOML configuration files using Jackson INI Format mConfigFormatINI Support for INI configuration files Mapper mConfigMapper Map configuration to Java objects SLF4J Logging mConfigLoggingSlf4j Logging integration with SLF4J <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigFull </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency> Other Available Modules \u00b6 Additional modules that are not included in mConfigStandard or mConfigFull : Module Artifact ID Description Cheese mConfigCheese some fragrant code for those with a taste for it planned Modules \u00b6 Module Artifact ID Description XML Format mConfigFormatXML Support for XML configuration files JUL Logging mConfigLoggingJUL Logging integration with Java Util Logging (Database Source) mConfigSource(DatabaseName) Read configuration from database (Remote Source) mConfigSource(NetworkService) Read configuration from remote servers","title":"mConfig Modules"},{"location":"examples/mconfig-modules.html#mconfig-modules","text":"mConfig is a modular library with which you can pick and choose the components you need.","title":"mConfig Modules"},{"location":"examples/mconfig-modules.html#choosing-your-modules","text":"Start simple : Use mConfigStandard for most applications Need more formats? : Use mConfigFull to get JSON, YAML, and JSON5 support Custom setup : Include only the specific modules you need Reduce if needed : start with 'mConfigCore' and add only what you need All modules share the same version number and are designed to work together seamlessly. Just add the modules you need to your project's dependencies. mConfig will automatically load them at runtime, when they are in the classpath. Java JPMS (since Java 9) considerations: see Java Platform Module System .","title":"Choosing Your Modules"},{"location":"examples/mconfig-modules.html#mconfigstandard-modules","text":"The mConfigStandard module provides a sensible minimum configuration to get started quickly. Module Artifact ID Description Core API mConfigCore Core interfaces and base classes File Source mConfigSourceFile configuration from files in standard OS locations System Properties Source mConfigSourceSystemProperties configuration from Java system properties Properties Format mConfigFormatJavaProperties Support for Java .properties file format Maven: <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigStandard </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency> Caveat: Do not omit/forget the type being pom . Gradle: implementation 'org.metabit.platform.support.config:mConfigStandard:${mconfig.version}'","title":"mConfigStandard Modules"},{"location":"examples/mconfig-modules.html#additional-mconfigfull-modules","text":"The mConfigFull module includes everything from mConfigStandard plus additional mature, stable modules: Module Artifact ID Description Environment Variables Source mConfigSourceEnvVar Read configuration from environment variables Windows Registry Source mConfigWinRegistry Read configuration from Windows Registry (Windows only) JSON Format mConfigFormatJSONwithJackson Support for JSON configuration files using Jackson JSON5 Format mConfigFormatJSONwithJackson Support for JSON5 configuration files using Jackson YAML (Jackson) Format mConfigFormatYAMLwithJackson Support for YAML configuration files using Jackson YAML (SnakeYAML) Format mConfigFormatYAMLwithSnakeYAML Support for YAML configuration files using SnakeYAML TOML Format mConfigFormatTOMLwithJackson Support for TOML configuration files using Jackson INI Format mConfigFormatINI Support for INI configuration files Mapper mConfigMapper Map configuration to Java objects SLF4J Logging mConfigLoggingSlf4j Logging integration with SLF4J <dependency> <groupId> org.metabit.platform.support.config </groupId> <artifactId> mConfigFull </artifactId> <version> ${mconfig.version} </version> <type> pom </type> </dependency>","title":"Additional mConfigFull Modules"},{"location":"examples/mconfig-modules.html#other-available-modules","text":"Additional modules that are not included in mConfigStandard or mConfigFull : Module Artifact ID Description Cheese mConfigCheese some fragrant code for those with a taste for it","title":"Other Available Modules"},{"location":"examples/mconfig-modules.html#planned-modules","text":"Module Artifact ID Description XML Format mConfigFormatXML Support for XML configuration files JUL Logging mConfigLoggingJUL Logging integration with Java Util Logging (Database Source) mConfigSource(DatabaseName) Read configuration from database (Remote Source) mConfigSource(NetworkService) Read configuration from remote servers","title":"planned Modules"},{"location":"examples/schemes.html","text":"Configuration Scheme Examples \u00b6 This page provides various examples of configuration schemes, ranging from simple key-value pairs to complex nested structures with validation. 1. Simple Application Configuration \u00b6 A basic scheme for a small application with a few parameters. [ { \"KEY\" : \"app/name\" , \"TYPE\" : \"STRING\" , \"DESCRIPTION\" : \"The name of the application.\" , \"DEFAULT\" : \"My Awesome App\" }, { \"KEY\" : \"app/version\" , \"TYPE\" : \"STRING\" , \"PATTERN\" : \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\" , \"DESCRIPTION\" : \"Application version (SemVer).\" , \"MANDATORY\" : true }, { \"KEY\" : \"app/debug\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ] 2. Network and Server Settings \u00b6 Using numeric ranges, enums, and list types. { \"network-settings\" : { \"NAME\" : \"network-settings\" , \"ENTRIES\" : [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"localhost\" , \"DESCRIPTION\" : \"Hostname or IP address.\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"PATTERN\" : \"uint16\" , \"DEFAULT\" : 8080 , \"DESCRIPTION\" : \"Port number (0-65535).\" }, { \"KEY\" : \"server/logLevel\" , \"TYPE\" : \"ENUM\" , \"PATTERN\" : \"DEBUG|INFO|WARN|ERROR\" , \"DEFAULT\" : \"INFO\" }, { \"KEY\" : \"server/allowedIps\" , \"TYPE\" : \"MULTIPLE_STRINGS\" , \"ARITY\" : \"1..*\" , \"DESCRIPTION\" : \"A list of IP addresses that are allowed to connect.\" } ] } } 3. Database Configuration with Secrets \u00b6 Handling sensitive data and mandatory fields. [ { \"KEY\" : \"db/url\" , \"TYPE\" : \"STRING\" , \"MANDATORY\" : true , \"DESCRIPTION\" : \"JDBC connection URL.\" }, { \"KEY\" : \"db/username\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"admin\" }, { \"KEY\" : \"db/password\" , \"TYPE\" : \"STRING\" , \"SECRET\" : true , \"DESCRIPTION\" : \"Database password (will be redacted in logs).\" }, { \"KEY\" : \"db/poolSize\" , \"TYPE\" : \"NUMBER\" , \"PATTERN\" : \"[1, 50]\" , \"DEFAULT\" : 10 } ] 4. Complex Validation with Arity \u00b6 Using ENUM_SET and arity constraints. { \"advanced-features\" : { \"ENTRIES\" : [ { \"KEY\" : \"features/enabled\" , \"TYPE\" : \"ENUM_SET\" , \"PATTERN\" : \"LOGGING|METRICS|TRACING|AUTH\" , \"ARITY\" : \"1..3\" , \"DEFAULT\" : [ \"LOGGING\" , \"METRICS\" ], \"DESCRIPTION\" : \"Select up to 3 features to enable.\" } ] } }","title":"Schemes"},{"location":"examples/schemes.html#configuration-scheme-examples","text":"This page provides various examples of configuration schemes, ranging from simple key-value pairs to complex nested structures with validation.","title":"Configuration Scheme Examples"},{"location":"examples/schemes.html#1-simple-application-configuration","text":"A basic scheme for a small application with a few parameters. [ { \"KEY\" : \"app/name\" , \"TYPE\" : \"STRING\" , \"DESCRIPTION\" : \"The name of the application.\" , \"DEFAULT\" : \"My Awesome App\" }, { \"KEY\" : \"app/version\" , \"TYPE\" : \"STRING\" , \"PATTERN\" : \"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\" , \"DESCRIPTION\" : \"Application version (SemVer).\" , \"MANDATORY\" : true }, { \"KEY\" : \"app/debug\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ]","title":"1. Simple Application Configuration"},{"location":"examples/schemes.html#2-network-and-server-settings","text":"Using numeric ranges, enums, and list types. { \"network-settings\" : { \"NAME\" : \"network-settings\" , \"ENTRIES\" : [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"localhost\" , \"DESCRIPTION\" : \"Hostname or IP address.\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"PATTERN\" : \"uint16\" , \"DEFAULT\" : 8080 , \"DESCRIPTION\" : \"Port number (0-65535).\" }, { \"KEY\" : \"server/logLevel\" , \"TYPE\" : \"ENUM\" , \"PATTERN\" : \"DEBUG|INFO|WARN|ERROR\" , \"DEFAULT\" : \"INFO\" }, { \"KEY\" : \"server/allowedIps\" , \"TYPE\" : \"MULTIPLE_STRINGS\" , \"ARITY\" : \"1..*\" , \"DESCRIPTION\" : \"A list of IP addresses that are allowed to connect.\" } ] } }","title":"2. Network and Server Settings"},{"location":"examples/schemes.html#3-database-configuration-with-secrets","text":"Handling sensitive data and mandatory fields. [ { \"KEY\" : \"db/url\" , \"TYPE\" : \"STRING\" , \"MANDATORY\" : true , \"DESCRIPTION\" : \"JDBC connection URL.\" }, { \"KEY\" : \"db/username\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"admin\" }, { \"KEY\" : \"db/password\" , \"TYPE\" : \"STRING\" , \"SECRET\" : true , \"DESCRIPTION\" : \"Database password (will be redacted in logs).\" }, { \"KEY\" : \"db/poolSize\" , \"TYPE\" : \"NUMBER\" , \"PATTERN\" : \"[1, 50]\" , \"DEFAULT\" : 10 } ]","title":"3. Database Configuration with Secrets"},{"location":"examples/schemes.html#4-complex-validation-with-arity","text":"Using ENUM_SET and arity constraints. { \"advanced-features\" : { \"ENTRIES\" : [ { \"KEY\" : \"features/enabled\" , \"TYPE\" : \"ENUM_SET\" , \"PATTERN\" : \"LOGGING|METRICS|TRACING|AUTH\" , \"ARITY\" : \"1..3\" , \"DEFAULT\" : [ \"LOGGING\" , \"METRICS\" ], \"DESCRIPTION\" : \"Select up to 3 features to enable.\" } ] } }","title":"4. Complex Validation with Arity"},{"location":"examples/simple_configuration_loading.html","text":"Simple Configuration Loading \u00b6 This example shows the minimal setup for loading a configuration and reading a few values. 1. Create a factory and configuration \u00b6 try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ). build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); String host = cfg . getString ( \"server/host\" ); int port = cfg . getInteger ( \"server/port\" ); boolean tls = cfg . getBoolean ( \"server/tls\" ); } 2. Provide defaults (recommended) \u00b6 Add defaults in your resources so the configuration works out of the box: src/main/resources/.config/ACME/ourApp/network.properties Example contents: server.host = 127.0.0.1 server.port = 8080 server.tls = false 3. Optional: add a scheme \u00b6 Add a scheme next to the config file to define types and defaults: src/main/resources/.config/ACME/ourApp/network.scheme.json [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 }, { \"KEY\" : \"server/tls\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ] Related docs: - Getting Started - Configuration Schemes","title":"Simple Configuration Loading"},{"location":"examples/simple_configuration_loading.html#simple-configuration-loading","text":"This example shows the minimal setup for loading a configuration and reading a few values.","title":"Simple Configuration Loading"},{"location":"examples/simple_configuration_loading.html#1-create-a-factory-and-configuration","text":"try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ). build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); String host = cfg . getString ( \"server/host\" ); int port = cfg . getInteger ( \"server/port\" ); boolean tls = cfg . getBoolean ( \"server/tls\" ); }","title":"1. Create a factory and configuration"},{"location":"examples/simple_configuration_loading.html#2-provide-defaults-recommended","text":"Add defaults in your resources so the configuration works out of the box: src/main/resources/.config/ACME/ourApp/network.properties Example contents: server.host = 127.0.0.1 server.port = 8080 server.tls = false","title":"2. Provide defaults (recommended)"},{"location":"examples/simple_configuration_loading.html#3-optional-add-a-scheme","text":"Add a scheme next to the config file to define types and defaults: src/main/resources/.config/ACME/ourApp/network.scheme.json [ { \"KEY\" : \"server/host\" , \"TYPE\" : \"STRING\" , \"DEFAULT\" : \"127.0.0.1\" }, { \"KEY\" : \"server/port\" , \"TYPE\" : \"NUMBER\" , \"DEFAULT\" : 8080 }, { \"KEY\" : \"server/tls\" , \"TYPE\" : \"BOOLEAN\" , \"DEFAULT\" : false } ] Related docs: - Getting Started - Configuration Schemes","title":"3. Optional: add a scheme"},{"location":"examples/testing_configurations.html","text":"Testing Configurations \u00b6 This example shows how to enable Test Mode and point mConfig at test-specific directories. 1. Enable Test Mode in code \u00b6 try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // ... test using cfg ... } 2. Provide test-only config files \u00b6 Place test configurations in your test resources: - src/test/resources/.config/ACME/ourApp/network.properties These take precedence in Test Mode, keeping production defaults intact. 3. JUnit example \u00b6 import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; import org.metabit.platform.support.config.* ; class NetworkConfigTest { @Test void loadsTestConfigDefaults () throws Exception { try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); assertEquals ( \"127.0.0.1\" , cfg . getString ( \"server/host\" )); assertEquals ( 8080 , cfg . getInteger ( \"server/port\" )); } } } 4. Override test directories explicitly (optional) \u00b6 If you want to point to custom test directories, use TESTMODE_DIRECTORIES : try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . setFeature ( ConfigFeature . TESTMODE_DIRECTORIES , List . of ( \"USER:/tmp/mconfig-tests/user\" , \"APPLICATION:/tmp/mconfig-tests/app\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // ... } 5. Security note \u00b6 Test Mode can be disabled globally with ConfigFactoryBuilder.forbidTestMode() . If you do that, TEST_MODE and setTestMode(true) have no effect. Related docs: - Test Mode - Configuration Schemes","title":"Testing Configurations"},{"location":"examples/testing_configurations.html#testing-configurations","text":"This example shows how to enable Test Mode and point mConfig at test-specific directories.","title":"Testing Configurations"},{"location":"examples/testing_configurations.html#1-enable-test-mode-in-code","text":"try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // ... test using cfg ... }","title":"1. Enable Test Mode in code"},{"location":"examples/testing_configurations.html#2-provide-test-only-config-files","text":"Place test configurations in your test resources: - src/test/resources/.config/ACME/ourApp/network.properties These take precedence in Test Mode, keeping production defaults intact.","title":"2. Provide test-only config files"},{"location":"examples/testing_configurations.html#3-junit-example","text":"import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; import org.metabit.platform.support.config.* ; class NetworkConfigTest { @Test void loadsTestConfigDefaults () throws Exception { try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); assertEquals ( \"127.0.0.1\" , cfg . getString ( \"server/host\" )); assertEquals ( 8080 , cfg . getInteger ( \"server/port\" )); } } }","title":"3. JUnit example"},{"location":"examples/testing_configurations.html#4-override-test-directories-explicitly-optional","text":"If you want to point to custom test directories, use TESTMODE_DIRECTORIES : try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"ACME\" , \"ourApp\" ) . setTestMode ( true ) . setFeature ( ConfigFeature . TESTMODE_DIRECTORIES , List . of ( \"USER:/tmp/mconfig-tests/user\" , \"APPLICATION:/tmp/mconfig-tests/app\" )) . build ()) { Configuration cfg = factory . getConfiguration ( \"network\" ); // ... }","title":"4. Override test directories explicitly (optional)"},{"location":"examples/testing_configurations.html#5-security-note","text":"Test Mode can be disabled globally with ConfigFactoryBuilder.forbidTestMode() . If you do that, TEST_MODE and setTestMode(true) have no effect. Related docs: - Test Mode - Configuration Schemes","title":"5. Security note"},{"location":"examples/zookeeper.html","text":"ZooKeeper Configuration Source (Experimental) \u00b6 The mConfigSourceZooKeeper module allows mConfig to retrieve configuration data from an Apache ZooKeeper ensemble. This is particularly useful for cluster-wide or organization-wide settings. 1. Bootstrap Configuration \u00b6 Following the \"self-configuration\" principle, the ZooKeeper source doesn't require hardcoded connection strings in your application code. Instead, it looks for its own settings in a configuration named zookeeper . You can provide these bootstrap settings in any standard mConfig location, such as a JAR resource (for defaults) or a local file (for overrides). Example: .config/zookeeper.json (Bootstrap) \u00b6 Place this file in src/main/resources/.config/zookeeper.json or /etc/metabit/myapp/zookeeper.json . { \"zookeeper\" : { \"connectString\" : \"zk-node-1:2181,zk-node-2:2181,zk-node-3:2181\" , \"rootPath\" : \"/mconfig/prod\" , \"sessionTimeoutMs\" : 30000 } } 2. Data Structure in ZooKeeper \u00b6 By default, the ZooKeeper source registers itself for the CLUSTER and ORGANIZATION scopes. It maps configuration names to ZNode paths relative to the rootPath . If your rootPath is /mconfig/prod , and you request a configuration named database-settings , the source will look at: - /mconfig/prod/cluster/database-settings - /mconfig/prod/organization/database-settings The content of the ZNode should be in a supported format (like JSON or Java Properties). Example: ZNode content at /mconfig/prod/cluster/app-config \u00b6 { \"database\" : { \"host\" : \"prod-db-server\" , \"port\" : 5432 }, \"features\" : { \"enableNewDashboard\" : true } } 3. Usage in Code \u00b6 To use the ZooKeeper source, simply include the mConfigSourceZooKeeper module in your classpath. mConfig will automatically discover and initialize it. // Standard initialization try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"metabit\" , \"myapp\" ). build ()) { // Requesting a configuration that might be in ZooKeeper Configuration config = factory . getConfig ( \"app-config\" ); // Accessing values (mConfig handles the layering) String dbHost = config . getString ( \"database/host\" ); boolean useDashboard = config . getBoolean ( \"features/enableNewDashboard\" ); } 4. How it Works (Self-Configuration) \u00b6 The ZooKeeper source follows a specific startup sequence: Local Initialization : JARConfigSource and FileConfigStorage are initialized first. Bootstrap Lookup : ZooKeeperConfigStorage calls factory.getConfig(\"zookeeper\") . This request is resolved using the already initialized local sources. Activation : If a connectString is found, the storage connects to ZooKeeper and adds its networked locations to the global search list. Transparent Layering : Subsequent calls to factory.getConfig(\"app-config\") will now automatically include layers found in ZooKeeper, prioritized by scope (e.g., CLUSTER settings will override DEFAULT settings from the JAR). 5. Test Mode Isolation \u00b6 In TEST_MODE , the ZooKeeper source will naturally point to your test resources (e.g., src/test/resources/.config/zookeeper.json ). This ensures that unit tests do not accidentally connect to production ZooKeeper ensembles. Related docs: - Test Mode","title":"ZooKeeper"},{"location":"examples/zookeeper.html#zookeeper-configuration-source-experimental","text":"The mConfigSourceZooKeeper module allows mConfig to retrieve configuration data from an Apache ZooKeeper ensemble. This is particularly useful for cluster-wide or organization-wide settings.","title":"ZooKeeper Configuration Source (Experimental)"},{"location":"examples/zookeeper.html#1-bootstrap-configuration","text":"Following the \"self-configuration\" principle, the ZooKeeper source doesn't require hardcoded connection strings in your application code. Instead, it looks for its own settings in a configuration named zookeeper . You can provide these bootstrap settings in any standard mConfig location, such as a JAR resource (for defaults) or a local file (for overrides).","title":"1. Bootstrap Configuration"},{"location":"examples/zookeeper.html#example-configzookeeperjson-bootstrap","text":"Place this file in src/main/resources/.config/zookeeper.json or /etc/metabit/myapp/zookeeper.json . { \"zookeeper\" : { \"connectString\" : \"zk-node-1:2181,zk-node-2:2181,zk-node-3:2181\" , \"rootPath\" : \"/mconfig/prod\" , \"sessionTimeoutMs\" : 30000 } }","title":"Example: .config/zookeeper.json (Bootstrap)"},{"location":"examples/zookeeper.html#2-data-structure-in-zookeeper","text":"By default, the ZooKeeper source registers itself for the CLUSTER and ORGANIZATION scopes. It maps configuration names to ZNode paths relative to the rootPath . If your rootPath is /mconfig/prod , and you request a configuration named database-settings , the source will look at: - /mconfig/prod/cluster/database-settings - /mconfig/prod/organization/database-settings The content of the ZNode should be in a supported format (like JSON or Java Properties).","title":"2. Data Structure in ZooKeeper"},{"location":"examples/zookeeper.html#example-znode-content-at-mconfigprodclusterapp-config","text":"{ \"database\" : { \"host\" : \"prod-db-server\" , \"port\" : 5432 }, \"features\" : { \"enableNewDashboard\" : true } }","title":"Example: ZNode content at /mconfig/prod/cluster/app-config"},{"location":"examples/zookeeper.html#3-usage-in-code","text":"To use the ZooKeeper source, simply include the mConfigSourceZooKeeper module in your classpath. mConfig will automatically discover and initialize it. // Standard initialization try ( ConfigFactory factory = ConfigFactoryBuilder . create ( \"metabit\" , \"myapp\" ). build ()) { // Requesting a configuration that might be in ZooKeeper Configuration config = factory . getConfig ( \"app-config\" ); // Accessing values (mConfig handles the layering) String dbHost = config . getString ( \"database/host\" ); boolean useDashboard = config . getBoolean ( \"features/enableNewDashboard\" ); }","title":"3. Usage in Code"},{"location":"examples/zookeeper.html#4-how-it-works-self-configuration","text":"The ZooKeeper source follows a specific startup sequence: Local Initialization : JARConfigSource and FileConfigStorage are initialized first. Bootstrap Lookup : ZooKeeperConfigStorage calls factory.getConfig(\"zookeeper\") . This request is resolved using the already initialized local sources. Activation : If a connectString is found, the storage connects to ZooKeeper and adds its networked locations to the global search list. Transparent Layering : Subsequent calls to factory.getConfig(\"app-config\") will now automatically include layers found in ZooKeeper, prioritized by scope (e.g., CLUSTER settings will override DEFAULT settings from the JAR).","title":"4. How it Works (Self-Configuration)"},{"location":"examples/zookeeper.html#5-test-mode-isolation","text":"In TEST_MODE , the ZooKeeper source will naturally point to your test resources (e.g., src/test/resources/.config/zookeeper.json ). This ensures that unit tests do not accidentally connect to production ZooKeeper ensembles. Related docs: - Test Mode","title":"5. Test Mode Isolation"}]}